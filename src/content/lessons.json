[
    {
        "title": "Arrays",
        "type": "datastructure",
        "difficulty": "easy",
        "duration": "0.5 hour",
        "lessons": [
            {
                "title": "Introduction to Arrays",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "An array is a data structure used to store multiple elements in a single variable. In Python, the most common way to represent arrays is through **lists**, which are dynamic in nature. Python also supports **static arrays** through the `array` module. In this tutorial, we\u2019ll explore both static and dynamic arrays."
                    }
                ]
            },
            {
                "title": "Static Arrays",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Static arrays have a fixed size and hold elements of the same type. They are more memory efficient and faster when working with large datasets of the same type. Python\u2019s `array` module allows us to create static arrays."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import array as arr\nmy_static_array = arr.array('i', [1, 2, 3, 4])\nprint(my_static_array)  # Output: array('i', [1, 2, 3, 4])"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we define a static array of integers (`'i'` stands for integer). Python provides different type codes, such as `'f'` for floats and `'u'` for Unicode characters."
                    }
                ]
            },
            {
                "title": "Dynamic Arrays (Lists)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Dynamic arrays in Python are represented using **lists**. Lists can grow or shrink in size and can hold elements of different data types, making them more versatile than static arrays."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dynamic_array = [1, 'apple', 3.14]\nprint(my_dynamic_array)  # Output: [1, 'apple', 3.14]"
                    },
                    {
                        "type": "paragraph",
                        "text": "As shown in this example, a Python list can hold elements of different data types such as integers, strings, and floats."
                    }
                ]
            },
            {
                "title": "Common Operations on Dynamic Arrays",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Dynamic arrays (lists) support several built-in operations. Let\u2019s explore some of the common operations on lists."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`append()`: Adds an element to the end of the list",
                            "`insert()`: Inserts an element at a specified position",
                            "`pop()`: Removes the element at a specified index",
                            "`remove()`: Removes the first occurrence of a specified value",
                            "`extend()`: Adds elements from another list to the current list"
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dynamic_array = [1, 2, 3]\nmy_dynamic_array.append(4)\nprint(my_dynamic_array)  # Output: [1, 2, 3, 4]\nmy_dynamic_array.remove(2)\nprint(my_dynamic_array)  # Output: [1, 3, 4]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we added an element to the end of the list using `append()` and removed an element using `remove()`."
                    }
                ]
            },
            {
                "title": "Looping Through Arrays (Lists)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "There are several ways to iterate over the elements of an array (list) in Python. Let\u2019s explore three common methods."
                    }
                ]
            },
            {
                "title": "Method 1: Using a For Loop",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The simplest way to loop through an array is using a `for` loop. This method iterates over each element in the array."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dynamic_array = [1, 2, 3, 4]\nfor item in my_dynamic_array:\n    print(item)"
                    }
                ]
            },
            {
                "title": "Method 2: Using enumerate()",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The `enumerate()` function allows you to access both the index and the value of the elements during iteration."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dynamic_array = [1, 2, 3, 4]\nfor index, item in enumerate(my_dynamic_array):\n    print(f'Index: {index}, Item: {item}')"
                    }
                ]
            },
            {
                "title": "Method 3: List Comprehension",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "List comprehensions provide a compact syntax for creating new lists from existing lists."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dynamic_array = [1, 2, 3, 4]\nsquared_array = [x**2 for x in my_dynamic_array]\nprint(squared_array)  # Output: [1, 4, 9, 16]"
                    }
                ]
            },
            {
                "title": "Multidimensional Arrays (Nested Lists)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In Python, lists can be nested to create multidimensional arrays, such as matrices. Each element in a list can be another list."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nfor row in matrix:\n    print(row)"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we created a 3x3 matrix using nested lists."
                    }
                ]
            },
            {
                "title": "Slicing Arrays",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Slicing allows you to retrieve a subset of elements from an array. The slicing syntax is `[start:stop:step]`, where `start` is the index to begin the slice, `stop` is the index to end the slice (exclusive), and `step` is the interval."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_array = [1, 2, 3, 4, 5]\nprint(my_array[1:4])  # Output: [2, 3, 4]\nprint(my_array[::2])  # Output: [1, 3, 5]"
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this lesson, we explored static arrays using Python\u2019s `array` module, dynamic arrays using lists, common operations, string manipulation, looping techniques, and slicing. Arrays are a foundational data structure that provides efficient ways to store and manipulate collections of data."
                    }
                ]
            }
        ]
    },
    {
        "title": "Strings",
        "type": "datastructure",
        "difficulty": "easy",
        "duration": "0.5 hour",
        "lessons": [
            {
                "title": "Introduction to Strings",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A string in Python is a sequence of characters enclosed in single (`'`) or double (`\"`) quotes. Strings are immutable, which means once a string is created, it cannot be modified. However, you can create new strings based on operations applied to the existing string."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_string = 'Hello, World!'\nprint(my_string)  # Output: Hello, World!"
                    },
                    {
                        "type": "paragraph",
                        "text": "In Python, you can easily perform operations like slicing, concatenation, and checking for substrings using built-in methods."
                    }
                ]
            },
            {
                "title": "Basic String Operations",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Python provides several built-in methods for working with strings. Some of the most common operations include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`len()`: Returns the length of the string.",
                            "`lower()`: Converts the string to lowercase.",
                            "`upper()`: Converts the string to uppercase.",
                            "`replace()`: Replaces a substring with another substring.",
                            "`split()`: Splits the string into a list of substrings.",
                            "`find()`: Returns the index of the first occurrence of a substring."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_string = 'Hello, World!'\nprint(len(my_string))  # Output: 13\nprint(my_string.lower())  # Output: hello, world!\nprint(my_string.replace('World', 'Python'))  # Output: Hello, Python!"
                    }
                ]
            },
            {
                "title": "String Slicing",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Slicing is a powerful feature in Python that allows you to extract a portion of a string. The basic syntax is `string[start:stop:step]`. You can omit any of the three parameters to use default values."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_string = 'Hello, World!'\nprint(my_string[0:5])  # Output: Hello\nprint(my_string[:5])   # Output: Hello\nprint(my_string[7:])   # Output: World!\nprint(my_string[::-1]) # Output: !dlroW ,olleH"
                    },
                    {
                        "type": "paragraph",
                        "text": "In the examples, we extract substrings and even reverse the string using the slicing technique. You can use negative indices to count from the end of the string."
                    }
                ]
            },
            {
                "title": "String Concatenation",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "String concatenation means combining multiple strings into one. In Python, you can concatenate strings using the `+` operator or `join()` method for a more efficient approach."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "str1 = 'Hello'\nstr2 = 'World'\nresult = str1 + ', ' + str2 + '!'  # Using +\nprint(result)  # Output: Hello, World!\nresult = ' '.join([str1, str2])  # Using join()\nprint(result)  # Output: Hello World"
                    },
                    {
                        "type": "paragraph",
                        "text": "The `join()` method is more efficient when concatenating a large number of strings compared to using `+`."
                    }
                ]
            },
            {
                "title": "String Formatting",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Python provides several ways to format strings, including the older `%` formatting, `str.format()` method, and the modern `f-strings` introduced in Python 3.6."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Using `%`: `'Hello %s' % 'World'`",
                            "Using `str.format()`: `'Hello {}'.format('World')`",
                            "Using `f-strings`: `f'Hello {name}'`"
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "name = 'Python'\nprint('Hello, %s!' % name)               # Output: Hello, Python!\nprint('Hello, {}!'.format(name))         # Output: Hello, Python!\nprint(f'Hello, {name}!')                 # Output: Hello, Python!"
                    },
                    {
                        "type": "paragraph",
                        "text": "Among these, **f-strings** are the most concise and readable, and they also support embedding expressions."
                    }
                ]
            },
            {
                "title": "Checking for Substrings",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can check if a substring is present in a string using the `in` keyword or `find()` method. The `in` keyword returns a boolean, while `find()` returns the index of the substring or `-1` if the substring is not found."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_string = 'Hello, World!'\nprint('World' in my_string)  # Output: True\nprint(my_string.find('World'))  # Output: 7\nprint(my_string.find('Python'))  # Output: -1"
                    }
                ]
            },
            {
                "title": "String Immutability",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Strings in Python are immutable, which means you cannot change the contents of a string after it\u2019s created. Instead, any operation that appears to modify a string actually creates a new string."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_string = 'Hello, World!'\nnew_string = my_string.replace('World', 'Python')\nprint(new_string)  # Output: Hello, Python!\nprint(my_string)   # Output: Hello, World!"
                    },
                    {
                        "type": "paragraph",
                        "text": "As shown, the `replace()` method creates a new string, leaving the original string unchanged."
                    }
                ]
            },
            {
                "title": "Escape Characters",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Sometimes, you may need to include special characters in a string. Python provides escape sequences, which start with a backslash (`\\`). Common escape sequences include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`\\n`: Newline",
                            "`\\t`: Tab",
                            "`\\'`: Single quote",
                            "`\\\"`: Double quote",
                            "`\\\\`: Backslash"
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_string = 'Hello\\nWorld!'\nprint(my_string)  # Output: Hello (newline) World!\n\nquote = 'She said, \\'Hello!\\''\nprint(quote)  # Output: She said, 'Hello!'"
                    }
                ]
            },
            {
                "title": "Looping Through Strings",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Strings are iterable in Python, meaning you can loop through each character in the string. The most common way to loop through a string is using a `for` loop."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_string = 'Hello'\nfor char in my_string:\n    print(char)"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we print each character of the string."
                    }
                ]
            },
            {
                "title": "Multiline Strings",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In Python, you can create multiline strings using triple quotes (`'''` or `\"\"\"`). This is useful for large text blocks or when formatting is important."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "multi_line_string = '''This is\na multiline\nstring.'''\nprint(multi_line_string)"
                    },
                    {
                        "type": "paragraph",
                        "text": "Multiline strings maintain their format and can span across multiple lines."
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we explored how to create, manipulate, and format strings in Python. Strings are an essential data structure, and understanding their behavior, immutability, and available operations is crucial for programming in Python."
                    }
                ]
            }
        ]
    },
    {
        "title": "Dictionaries",
        "type": "datastructure",
        "difficulty": "easy",
        "duration": "0.5 hour",
        "lessons": [
            {
                "title": "Introduction to Dictionaries",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **dictionary**, also known as a **hashmap** in other programming languages, is a collection of key-value pairs. Dictionaries in Python are unordered, changeable, and do not allow duplicate keys. They allow for fast access to data by using keys to look up values."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dict = {'name': 'John', 'age': 25, 'city': 'New York'}\nprint(my_dict)  # Output: {'name': 'John', 'age': 25, 'city': 'New York'}"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the dictionary `my_dict` contains three key-value pairs: `'name'`, `'age'`, and `'city'`. The keys must be unique and immutable (strings, numbers, or tuples), while the values can be of any data type."
                    }
                ]
            },
            {
                "title": "Accessing Dictionary Values",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can access the value associated with a key by using the key in square brackets or by using the `get()` method. The `get()` method allows you to specify a default value if the key doesn\u2019t exist."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dict = {'name': 'John', 'age': 25}\nprint(my_dict['name'])  # Output: John\nprint(my_dict.get('age'))  # Output: 25\nprint(my_dict.get('city', 'Not Found'))  # Output: Not Found"
                    },
                    {
                        "type": "paragraph",
                        "text": "If you use square brackets and the key is not found, Python will raise a `KeyError`. However, using `get()` with a default value avoids this."
                    }
                ]
            },
            {
                "title": "Adding and Modifying Dictionary Elements",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Dictionaries are mutable, so you can add or modify key-value pairs by assigning a value to a key. If the key already exists, its value will be updated. If the key doesn\u2019t exist, a new key-value pair will be added."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dict = {'name': 'John', 'age': 25}\nmy_dict['city'] = 'New York'  # Adding a new key-value pair\nmy_dict['age'] = 30  # Modifying an existing key's value\nprint(my_dict)  # Output: {'name': 'John', 'age': 30, 'city': 'New York'}"
                    }
                ]
            },
            {
                "title": "Removing Dictionary Elements",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can remove elements from a dictionary using methods such as `pop()`, `del`, and `popitem()`. The `clear()` method can be used to remove all elements from the dictionary."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`pop(key)`: Removes the element with the specified key and returns its value.",
                            "`del dictionary[key]`: Removes the element with the specified key.",
                            "`popitem()`: Removes and returns the last inserted key-value pair.",
                            "`clear()`: Removes all key-value pairs from the dictionary."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dict = {'name': 'John', 'age': 25, 'city': 'New York'}\nage = my_dict.pop('age')\nprint(age)  # Output: 25\ndel my_dict['city']\nprint(my_dict)  # Output: {'name': 'John'}\nmy_dict.clear()\nprint(my_dict)  # Output: {}"
                    }
                ]
            },
            {
                "title": "Checking for Keys in a Dictionary",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can check if a specific key exists in a dictionary using the `in` keyword. This is useful when you want to verify if a key exists before accessing its value."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dict = {'name': 'John', 'age': 25}\nif 'name' in my_dict:\n    print('Name is present.')  # Output: Name is present\n\nif 'city' not in my_dict:\n    print('City is not present.')  # Output: City is not present"
                    }
                ]
            },
            {
                "title": "Looping Through Dictionaries",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can loop through the keys, values, or both key-value pairs of a dictionary. Python provides several built-in methods like `keys()`, `values()`, and `items()` to retrieve the keys, values, or both."
                    }
                ]
            },
            {
                "title": "Method 1: Looping Through Keys",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The simplest way to loop through a dictionary is by iterating over its keys using a `for` loop."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dict = {'name': 'John', 'age': 25}\nfor key in my_dict:\n    print(key)  # Output: name, age"
                    }
                ]
            },
            {
                "title": "Method 2: Looping Through Values",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can retrieve and loop through the values of a dictionary using the `values()` method."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dict = {'name': 'John', 'age': 25}\nfor value in my_dict.values():\n    print(value)  # Output: John, 25"
                    }
                ]
            },
            {
                "title": "Method 3: Looping Through Key-Value Pairs",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To retrieve both keys and values during iteration, you can use the `items()` method."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_dict = {'name': 'John', 'age': 25}\nfor key, value in my_dict.items():\n    print(f'{key}: {value}')  # Output: name: John, age: 25"
                    }
                ]
            },
            {
                "title": "Dictionary Comprehension",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Just like list comprehensions, Python allows you to create dictionaries using **dictionary comprehensions**. This is a concise way to create dictionaries from iterables."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "squares = {x: x**2 for x in range(5)}\nprint(squares)  # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we use a dictionary comprehension to create a dictionary where the keys are numbers from 0 to 4 and the values are their squares."
                    }
                ]
            },
            {
                "title": "Merging Dictionaries",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Starting from Python 3.9, dictionaries can be merged using the `|` operator. For older versions, you can use the `update()` method to merge two dictionaries."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "dict1 = {'a': 1, 'b': 2}\ndict2 = {'b': 3, 'c': 4}\nmerged_dict = dict1 | dict2  # Using the | operator\nprint(merged_dict)  # Output: {'a': 1, 'b': 3, 'c': 4}\n\n# Using update()\ndict1.update(dict2)\nprint(dict1)  # Output: {'a': 1, 'b': 3, 'c': 4}"
                    },
                    {
                        "type": "paragraph",
                        "text": "The `|` operator creates a new dictionary by merging two dictionaries, whereas `update()` modifies the original dictionary."
                    }
                ]
            },
            {
                "title": "Handling Default Values with defaultdict",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The `collections.defaultdict` class is a subclass of Python\u2019s built-in `dict` class. It provides a default value for a key that doesn\u2019t exist, so you don\u2019t have to check whether the key is present before adding or modifying its value."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "from collections import defaultdict\nmy_dict = defaultdict(int)\nmy_dict['count'] += 1\nprint(my_dict)  # Output: defaultdict(<class 'int'>, {'count': 1})"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the `defaultdict(int)` creates a dictionary where the default value for any missing key is `0`. This avoids the need to check if the key exists before incrementing its value."
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we covered the basic operations, methods, and use cases of Python dictionaries (hashmaps). Dictionaries are one of the most powerful data structures in Python, offering fast lookups, insertion, and deletion operations. With additional features like dictionary comprehensions, merging, and handling default values, dictionaries provide a flexible and efficient way to manage key-value pairs in Python."
                    }
                ]
            }
        ]
    },
    {
        "title": "Sets",
        "type": "datastructure",
        "difficulty": "easy",
        "duration": "0.25 hour",
        "lessons": [
            {
                "title": "Introduction to Sets",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **set** in Python is an unordered collection of unique elements. Sets are mutable, which means you can add or remove elements after a set is created. They do not allow duplicate elements, and because they are unordered, they cannot be indexed or sliced."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_set = {1, 2, 3, 4, 5}\nprint(my_set)  # Output: {1, 2, 3, 4, 5}"
                    },
                    {
                        "type": "paragraph",
                        "text": "Sets are particularly useful when you want to ensure that an element appears only once, or when you need to perform operations such as unions, intersections, and differences on collections of data."
                    }
                ]
            },
            {
                "title": "Creating Sets",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Sets can be created using curly braces (`{}`) or by using the `set()` constructor. Keep in mind that sets only store immutable (unchangeable) elements, such as numbers, strings, or tuples, but not lists or dictionaries."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_set = {1, 2, 3, 4, 5}\nempty_set = set()  # Create an empty set using set()\nprint(empty_set)  # Output: set()"
                    }
                ]
            },
            {
                "title": "Adding and Removing Elements",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Elements can be added to a set using the `add()` method, and removed using methods like `remove()`, `discard()`, and `pop()`."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`add()`: Adds a single element to the set.",
                            "`remove()`: Removes a specific element from the set (raises an error if the element doesn\u2019t exist).",
                            "`discard()`: Removes a specific element, but doesn\u2019t raise an error if the element doesn\u2019t exist.",
                            "`pop()`: Removes and returns an arbitrary element from the set."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_set = {1, 2, 3}\nmy_set.add(4)\nprint(my_set)  # Output: {1, 2, 3, 4}\nmy_set.remove(2)\nprint(my_set)  # Output: {1, 3, 4}\nmy_set.discard(10)  # No error if 10 doesn\u2019t exist"
                    }
                ]
            },
            {
                "title": "Set Operations",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Python provides several powerful set operations that allow you to combine, compare, or modify sets. These operations include **union**, **intersection**, **difference**, and **symmetric difference**."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`union()`: Returns a set containing all unique elements from both sets.",
                            "`intersection()`: Returns a set containing elements common to both sets.",
                            "`difference()`: Returns a set containing elements in the first set that are not in the second set.",
                            "`symmetric_difference()`: Returns a set containing elements that are in either set, but not in both."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "set1 = {1, 2, 3}\nset2 = {3, 4, 5}\nunion_set = set1.union(set2)\nprint(union_set)  # Output: {1, 2, 3, 4, 5}\nintersection_set = set1.intersection(set2)\nprint(intersection_set)  # Output: {3}\ndifference_set = set1.difference(set2)\nprint(difference_set)  # Output: {1, 2}\nsymmetric_difference_set = set1.symmetric_difference(set2)\nprint(symmetric_difference_set)  # Output: {1, 2, 4, 5}"
                    }
                ]
            },
            {
                "title": "Checking Subsets and Supersets",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can check if a set is a subset or superset of another set using `issubset()` and `issuperset()`. A subset contains all elements of another set, while a superset contains at least all elements of another set."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "set1 = {1, 2, 3}\nset2 = {1, 2}\nprint(set2.issubset(set1))  # Output: True\nprint(set1.issuperset(set2))  # Output: True"
                    }
                ]
            },
            {
                "title": "Frozensets (Immutable Sets)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **frozenset** is an immutable version of a set, meaning once a frozenset is created, you cannot add or remove elements from it. Frozensets are useful when you need to create a constant set that should not be modified."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_frozenset = frozenset([1, 2, 3, 4])\nprint(my_frozenset)  # Output: frozenset({1, 2, 3, 4})"
                    }
                ]
            },
            {
                "title": "Set Comprehension",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Similar to list comprehensions, you can use **set comprehension** to create sets based on an existing iterable in a concise way."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "squared_set = {x**2 for x in range(5)}\nprint(squared_set)  # Output: {0, 1, 4, 9, 16}"
                    }
                ]
            },
            {
                "title": "Looping Through a Set",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Although sets are unordered, you can still loop through the elements in a set using a `for` loop."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_set = {1, 2, 3, 4}\nfor item in my_set:\n    print(item)"
                    },
                    {
                        "type": "paragraph",
                        "text": "Since sets are unordered, the elements will not necessarily be printed in the order they were added."
                    }
                ]
            },
            {
                "title": "Checking Membership in a Set",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can check if an element exists in a set using the `in` keyword. This is one of the most common operations in sets, as sets are optimized for fast membership checks."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "my_set = {1, 2, 3, 4}\nprint(3 in my_set)  # Output: True\nprint(5 in my_set)  # Output: False"
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this lesson, we covered the basics of sets in Python, including how to create sets, add and remove elements, perform set operations, and use frozensets. Sets are an excellent choice when you need to store unique elements and perform common mathematical operations like unions and intersections."
                    }
                ]
            }
        ]
    },
    {
        "title": "Two Pointers",
        "type": "concept",
        "difficulty": "easy",
        "duration": "1 hour",
        "lessons": [
            {
                "title": "Introduction to Two Pointers Technique",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The two pointers technique is a common algorithmic approach used to solve problems involving arrays or lists. It involves maintaining two pointers (or indices) that move towards each other or in the same direction to solve a problem efficiently."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "The two pointers technique is useful for problems involving searching, sorting, or identifying specific subarrays or subsequences.",
                            "It is often used to optimize time complexity from O(n^2) to O(n) by avoiding nested loops."
                        ]
                    }
                ]
            },
            {
                "title": "Common Use Cases of Two Pointers",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Finding pairs of elements in a sorted array that satisfy a condition (e.g., two-sum problem).",
                            "Reversing or comparing elements in a string or array.",
                            "Identifying subarrays or subsequences within arrays (e.g., sliding window problems).",
                            "Merging two sorted arrays or linked lists."
                        ]
                    }
                ]
            },
            {
                "title": "Example: Two-Sum Problem (Sorted Array)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In the two-sum problem, we are given a sorted array and a target sum. We need to find two numbers that add up to the target. By using two pointers, one starting at the beginning of the array and the other at the end, we can efficiently find the solution."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def two_sum(arr, target):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]  # Return the indices of the two elements\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []  # No solution found\n\narr = [1, 2, 3, 4, 6]\ntarget = 6\nprint(two_sum(arr, target))  # Output: [1, 3]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we use two pointers starting at opposite ends of the sorted array. The pointers move towards each other depending on whether the sum of the current elements is less than or greater than the target. This approach has a time complexity of O(n), compared to the O(n^2) time complexity of a brute-force solution."
                    }
                ]
            },
            {
                "title": "Example: Reversing a String Using Two Pointers",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The two pointers technique can also be used to reverse a string or an array by swapping elements from both ends and moving the pointers towards the center."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def reverse_string(s):\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return ''.join(s)\n\ns = \"hello\"\nprint(reverse_string(s))  # Output: \"olleh\""
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the two pointers start at the beginning and end of the string. The characters are swapped, and the pointers move towards the center. This approach runs in O(n) time."
                    }
                ]
            },
            {
                "title": "Example: Merging Two Sorted Arrays",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Another common use of the two pointers technique is merging two sorted arrays. By maintaining a pointer for each array, we can merge them into a single sorted array in O(n) time."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def merge_sorted_arrays(arr1, arr2):\n    i, j = 0, 0\n    merged = []\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n\n    return merged\n\narr1 = [1, 3, 5, 7]\narr2 = [2, 4, 6, 8]\nprint(merge_sorted_arrays(arr1, arr2))  # Output: [1, 2, 3, 4, 5, 6, 7, 8]"
                    },
                    {
                        "type": "paragraph",
                        "text": "Here, the two pointers traverse both sorted arrays, comparing elements and merging them into one sorted array. This technique takes O(n) time, where n is the total number of elements in both arrays."
                    }
                ]
            },
            {
                "title": "Example: Valid Palindrome",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The two pointers technique can also be used to determine if a string is a palindrome. The two pointers start at opposite ends of the string and move towards the center, comparing characters along the way."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def is_palindrome(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\ns = \"racecar\"\nprint(is_palindrome(s))  # Output: True"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, two pointers start from both ends of the string and compare the characters. If any pair of characters is not equal, the string is not a palindrome. The time complexity is O(n)."
                    }
                ]
            },
            {
                "title": "Two Pointers in Linked Lists",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The two pointers technique is also useful for solving problems on linked lists, such as finding the middle element, detecting cycles, or reversing a linked list."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Detecting a Cycle: The 'Floyd's Cycle Detection' algorithm uses two pointers, one moving faster than the other, to detect cycles in a linked list.",
                            "Finding the Middle: Two pointers, one moving twice as fast as the other, can be used to find the middle of a linked list."
                        ]
                    }
                ]
            },
            {
                "title": "Example: Detecting a Cycle in a Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To detect a cycle in a linked list, the 'Floyd\u2019s Cycle Detection' algorithm uses two pointers: a slow pointer that moves one node at a time and a fast pointer that moves two nodes at a time. If the linked list has a cycle, the two pointers will eventually meet."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n# Floyd's Cycle Detection Algorithm\ndef has_cycle(head):\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True  # Cycle detected\n    return False  # No cycle\n\n# Example usage\nhead = ListNode(1)\nhead.next = ListNode(2)\nhead.next.next = ListNode(3)\nhead.next.next.next = head  # Creates a cycle\nprint(has_cycle(head))  # Output: True"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the fast pointer moves two steps while the slow pointer moves one step. If there is a cycle, the two pointers will eventually meet. The time complexity is O(n), and the space complexity is O(1)."
                    }
                ]
            },
            {
                "title": "Advantages and Applications of Two Pointers",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "The two pointers technique reduces the need for nested loops, improving the time complexity of many problems from O(n^2) to O(n).",
                            "It is particularly useful in problems involving arrays, strings, and linked lists, such as finding pairs, reversing data, or detecting patterns."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The two pointers technique is an elegant and efficient solution to many common problems in computer science. By maintaining two pointers and processing elements in a single pass, it optimizes time complexity for various tasks such as finding pairs, merging arrays, and solving linked list problems."
                    }
                ]
            }
        ]
    },
    {
        "title": "Stacks",
        "type": "datastructure",
        "difficulty": "easy",
        "duration": "1 hour",
        "lessons": [
            {
                "title": "Introduction to Stacks",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **stack** is a data structure that follows the **LIFO (Last In, First Out)** principle, meaning the last element added is the first one to be removed. Stacks are used in many algorithms, including depth-first search (DFS), backtracking, and managing function calls in recursion."
                    },
                    {
                        "type": "paragraph",
                        "text": "A stack allows two main operations: **push** (to add an element to the stack) and **pop** (to remove the top element from the stack). The top of the stack is the most recently added element."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Python doesn\u2019t have a built-in stack data structure, but you can use a list to implement a stack.\nstack = []\nstack.append(1)  # Push\nstack.append(2)\nprint(stack)  # Output: [1, 2]\nstack.pop()  # Pop the top element\nprint(stack)  # Output: [1]"
                    }
                ]
            },
            {
                "title": "Basic Stack Operations",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The most common operations performed on a stack include `push`, `pop`, `peek`, and `isEmpty`. Python's list can be used to simulate these operations."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`push()`: Adds an element to the top of the stack.",
                            "`pop()`: Removes the element from the top of the stack.",
                            "`peek()`: Returns the element at the top of the stack without removing it.",
                            "`isEmpty()`: Checks if the stack is empty."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Simulating basic stack operations\nstack = []\n\n# Push elements\nstack.append(10)\nstack.append(20)\nstack.append(30)\nprint(stack)  # Output: [10, 20, 30]\n\n# Pop the top element\nprint(stack.pop())  # Output: 30\nprint(stack)  # Output: [10, 20]\n\n# Peek the top element without removing\nprint(stack[-1])  # Output: 20\n\n# Check if the stack is empty\nprint(len(stack) == 0)  # Output: False"
                    },
                    {
                        "type": "paragraph",
                        "text": "The `pop()` method removes the top element from the stack, while `peek()` allows us to view the top element without removing it. The stack is empty if its length is zero."
                    }
                ]
            },
            {
                "title": "Common Use Cases of Stacks",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Stacks are widely used in computer science and have several important applications, including:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Undo operations**: In text editors, stacks are used to store operations that can be undone.",
                            "**Backtracking**: Algorithms like depth-first search (DFS) use stacks to track visited nodes.",
                            "**Expression evaluation**: Stacks are used to evaluate expressions in compilers.",
                            "**Function call management**: The call stack stores information about active subroutines in programming languages."
                        ]
                    }
                ]
            },
            {
                "title": "Checking for Balanced Parentheses (A Stack Application)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "One common problem that can be solved using a stack is checking whether an expression has balanced parentheses. For example, the expression `(())` is balanced, while the expression `(()` is not."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def is_balanced(expression):\n    stack = []\n    for char in expression:\n        if char in '({[':\n            stack.append(char)\n        elif char in ')}]':\n            if not stack:\n                return False\n            top = stack.pop()\n            if (top == '(' and char != ')') or (top == '{' and char != '}') or (top == '[' and char != ']'):\n                return False\n    return len(stack) == 0\n\n# Test the function\nexpression = '({[]})'\nprint(is_balanced(expression))  # Output: True\nexpression = '({[})'\nprint(is_balanced(expression))  # Output: False"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the stack stores opening parentheses, and when a closing parenthesis is encountered, it checks whether it matches the most recent opening parenthesis. If all parentheses are matched correctly, the expression is balanced."
                    }
                ]
            },
            {
                "title": "Reversing a String Using a Stack",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Stacks can be used to reverse strings. The approach is simple: push each character of the string onto a stack and then pop characters off the stack to get them in reverse order."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def reverse_string(s):\n    stack = []\n    for char in s:\n        stack.append(char)\n    reversed_str = ''\n    while stack:\n        reversed_str += stack.pop()\n    return reversed_str\n\n# Test the function\nstring = 'hello'\nprint(reverse_string(string))  # Output: 'olleh'"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the string `'hello'` is reversed by pushing each character onto the stack and popping them in reverse order."
                    }
                ]
            },
            {
                "title": "Implementing a Stack Using a Class",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Although Python\u2019s list can be used to implement a stack, it's often useful to encapsulate stack behavior into a class for better organization and reusability."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if not self.is_empty():\n            return self.stack.pop()\n        return None  # Stack is empty\n\n    def peek(self):\n        if not self.is_empty():\n            return self.stack[-1]\n        return None\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\n    def size(self):\n        return len(self.stack)\n\n# Test the Stack class\nstack = Stack()\nstack.push(10)\nstack.push(20)\nprint(stack.peek())  # Output: 20\nprint(stack.pop())  # Output: 20\nprint(stack.size())  # Output: 1"
                    },
                    {
                        "type": "paragraph",
                        "text": "This `Stack` class implements the basic stack operations like `push`, `pop`, `peek`, and `is_empty`. The `size()` method returns the number of elements in the stack."
                    }
                ]
            },
            {
                "title": "Stack vs. Queue",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Although both stacks and queues are fundamental data structures, they differ in how they handle elements. A stack follows the **LIFO** principle, while a queue follows the **FIFO (First In, First Out)** principle."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Stacks remove the last element added (LIFO).",
                            "Queues remove the first element added (FIFO)."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "For example, in a stack, the last plate placed on the pile is the first one removed. In a queue, the first person in line is the first one to be served."
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we covered the fundamental operations of stacks, their use cases, and common problems that can be solved using stacks, such as checking for balanced parentheses and reversing a string. Understanding stacks is essential for implementing algorithms that require a LIFO approach."
                    }
                ]
            }
        ]
    },
    {
        "title": "Queues",
        "type": "datastructure",
        "difficulty": "easy",
        "duration": "1 hour",
        "lessons": [
            {
                "title": "Introduction to Queues",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **queue** is a data structure that follows the **FIFO (First In, First Out)** principle. This means that the first element added to the queue is the first one to be removed. Queues are commonly used in scenarios like task scheduling, buffering, and managing resources in a fair order."
                    },
                    {
                        "type": "paragraph",
                        "text": "A queue supports two main operations: **enqueue** (to add an element to the end of the queue) and **dequeue** (to remove an element from the front of the queue)."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Python\u2019s list can be used to simulate a queue, but the collections.deque module is more efficient.\nfrom collections import deque\nqueue = deque()\nqueue.append(1)  # Enqueue\nqueue.append(2)\nprint(queue)  # Output: deque([1, 2])\nqueue.popleft()  # Dequeue\nprint(queue)  # Output: deque([2])"
                    }
                ]
            },
            {
                "title": "Basic Queue Operations",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The most common operations performed on a queue include `enqueue`, `dequeue`, `peek`, and `isEmpty`. Python\u2019s `collections.deque` is optimized for both enqueueing and dequeueing operations from either end of the deque."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`enqueue()`: Adds an element to the back of the queue.",
                            "`dequeue()`: Removes and returns the element from the front of the queue.",
                            "`peek()`: Returns the element at the front of the queue without removing it.",
                            "`isEmpty()`: Checks if the queue is empty."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Simulating basic queue operations\nfrom collections import deque\nqueue = deque()\n\n# Enqueue elements\nqueue.append(10)\nqueue.append(20)\nqueue.append(30)\nprint(queue)  # Output: deque([10, 20, 30])\n\n# Dequeue the front element\nprint(queue.popleft())  # Output: 10\nprint(queue)  # Output: deque([20, 30])\n\n# Peek at the front element\nprint(queue[0])  # Output: 20\n\n# Check if the queue is empty\nprint(len(queue) == 0)  # Output: False"
                    }
                ]
            },
            {
                "title": "Common Use Cases of Queues",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Queues are widely used in computer science and have several important applications, including:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Task scheduling**: Queues are used to manage tasks in order of arrival in operating systems.",
                            "**Breadth-First Search (BFS)**: BFS traversal of trees and graphs uses a queue to explore nodes level by level.",
                            "**Resource management**: Queues are used in managing resources like printers and network bandwidth.",
                            "**Buffering**: Queues are used to handle buffering in data streams, such as video streaming."
                        ]
                    }
                ]
            },
            {
                "title": "Breadth-First Search (BFS) Using Queues",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "One of the most common uses of queues is in implementing the **Breadth-First Search (BFS)** algorithm. BFS explores all nodes at the present depth level before moving on to nodes at the next depth level. It uses a queue to keep track of which node to explore next."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "from collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        node = queue.popleft()\n        print(node, end=' ')\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n# Example graph\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\nbfs(graph, 'A')  # Output: A B C D E F"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, BFS uses a queue to explore all neighbors of a node before moving on to the next node. The queue helps in ensuring that nodes are explored in the correct order."
                    }
                ]
            },
            {
                "title": "Implementing a Queue Using a Class",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "While Python\u2019s `deque` module is very efficient for queue operations, we can implement a queue using a class to better encapsulate its behavior."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class Queue:\n    def __init__(self):\n        self.queue = deque()\n\n    def enqueue(self, value):\n        self.queue.append(value)\n\n    def dequeue(self):\n        if not self.is_empty():\n            return self.queue.popleft()\n        return None  # Queue is empty\n\n    def peek(self):\n        if not self.is_empty():\n            return self.queue[0]\n        return None\n\n    def is_empty(self):\n        return len(self.queue) == 0\n\n    def size(self):\n        return len(self.queue)\n\n# Test the Queue class\nqueue = Queue()\nqueue.enqueue(10)\nqueue.enqueue(20)\nprint(queue.peek())  # Output: 10\nprint(queue.dequeue())  # Output: 10\nprint(queue.size())  # Output: 1"
                    },
                    {
                        "type": "paragraph",
                        "text": "This `Queue` class encapsulates the basic operations of a queue such as `enqueue`, `dequeue`, `peek`, `is_empty`, and `size` using a `deque` internally for efficient operations."
                    }
                ]
            },
            {
                "title": "Circular Queues",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **circular queue** is a type of queue where the last position is connected back to the first position, forming a circle. This is useful when managing fixed-size buffers. In a circular queue, if the rear reaches the end of the queue, it wraps around to the front."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class CircularQueue:\n    def __init__(self, size):\n        self.size = size\n        self.queue = [None] * size\n        self.front = self.rear = -1\n\n    def enqueue(self, value):\n        if (self.rear + 1) % self.size == self.front:\n            print('Queue is full!')\n        elif self.front == -1:\n            self.front = self.rear = 0\n            self.queue[self.rear] = value\n        else:\n            self.rear = (self.rear + 1) % self.size\n            self.queue[self.rear] = value\n\n    def dequeue(self):\n        if self.front == -1:\n            print('Queue is empty!')\n        elif self.front == self.rear:\n            self.front = self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.size\n\n    def display(self):\n        if self.front == -1:\n            print('Queue is empty!')\n        else:\n            i = self.front\n            while i != self.rear:\n                print(self.queue[i], end=' ')\n                i = (i + 1) % self.size\n            print(self.queue[self.rear])\n\n# Test CircularQueue\ncq = CircularQueue(5)\ncq.enqueue(1)\ncq.enqueue(2)\ncq.enqueue(3)\ncq.enqueue(4)\ncq.enqueue(5)\ncq.display()  # Output: 1 2 3 4"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we create a circular queue of size 5. When the rear of the queue reaches the end of the list, it wraps around to the front if there is space."
                    }
                ]
            },
            {
                "title": "Queue vs. Stack",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "While both queues and stacks are fundamental data structures, they differ in the order of removing elements. A **queue** follows the **FIFO (First In, First Out)** principle, while a **stack** follows the **LIFO (Last In, First Out)** principle."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Queues remove the first element added (FIFO).",
                            "Stacks remove the last element added (LIFO)."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "For example, in a queue, the first person in line is served first, while in a stack, the last item placed is the first one to be removed."
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we explored the basic operations of queues, their use cases, and common problems that can be solved using queues, such as Breadth-First Search (BFS) and task scheduling. Understanding queues is essential for solving problems that require a FIFO approach."
                    }
                ]
            }
        ]
    },
    {
        "title": "Monotonic Stacks",
        "type": "datastructure",
        "difficulty": "medium",
        "duration": "1.5 hours",
        "lessons": [
            {
                "title": "Introduction to Monotonic Stacks",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **monotonic stack** is a specialized stack that maintains its elements in a specific order (either increasing or decreasing). These stacks are useful in solving problems where you need to efficiently maintain a relationship between elements as you iterate over them."
                    },
                    {
                        "type": "paragraph",
                        "text": "There are two types of monotonic stacks: **increasing stacks** (where each element is greater than or equal to the previous element) and **decreasing stacks** (where each element is smaller than or equal to the previous element)."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Example: Monotonic Increasing Stack\nstack = []\narr = [5, 3, 8, 4, 6]\nfor num in arr:\n    while stack and stack[-1] > num:\n        stack.pop()\n    stack.append(num)\nprint(stack)  # Output: [3, 4, 6]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the stack maintains an increasing order. Each time we encounter a number smaller than the top of the stack, we pop the stack."
                    }
                ]
            },
            {
                "title": "When to Use Monotonic Stacks",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Monotonic stacks are often used in problems that require efficient searching for the next or previous smaller or larger element, like **finding the next greater element** or solving problems related to **sliding windows**."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Finding the next greater or smaller element in a sequence.",
                            "Efficiently solving problems with constraints based on the relative ordering of elements.",
                            "Problems involving maintaining a window of elements with certain order properties."
                        ]
                    }
                ]
            },
            {
                "title": "Problem 1: Next Greater Element",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The **Next Greater Element** problem is a classic use case of monotonic stacks. For each element in the array, the goal is to find the first element to its right that is greater than the current element."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def next_greater_element(nums):\n    stack = []\n    result = [-1] * len(nums)\n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            result[stack.pop()] = nums[i]\n        stack.append(i)\n    return result\n\n# Test the function\nnums = [2, 1, 2, 4, 3]\nprint(next_greater_element(nums))  # Output: [4, 2, 4, -1, -1]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we use a stack to store the indices of elements. For each element, we pop from the stack until we find an element greater than the current one, updating the result list with the next greater element."
                    }
                ]
            },
            {
                "title": "Problem 2: Daily Temperatures",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In the **Daily Temperatures** problem, for each day, you need to find how many days must pass before a warmer day. If there is no such day, return `0`."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def daily_temperatures(T):\n    stack = []\n    result = [0] * len(T)\n    for i in range(len(T)):\n        while stack and T[i] > T[stack[-1]]:\n            prev_day = stack.pop()\n            result[prev_day] = i - prev_day\n        stack.append(i)\n    return result\n\n# Test the function\nT = [73, 74, 75, 71, 69, 72, 76, 73]\nprint(daily_temperatures(T))  # Output: [1, 1, 4, 2, 1, 1, 0, 0]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this problem, we use a decreasing monotonic stack to keep track of temperatures. We store the indices of the temperatures in the stack and calculate how far the next warmer day is for each day."
                    }
                ]
            },
            {
                "title": "Problem 3: Trapping Rain Water",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The **Trapping Rain Water** problem involves finding the amount of water trapped after raining between buildings of different heights. This is a more complex use of a monotonic stack."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def trap(height):\n    stack = []\n    water = 0\n    for i in range(len(height)):\n        while stack and height[i] > height[stack[-1]]:\n            h = height[stack.pop()]\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - h\n            water += distance * bounded_height\n    return water\n\n# Test the function\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trap(height))  # Output: 6"
                    },
                    {
                        "type": "paragraph",
                        "text": "Here, we use a stack to store indices of the bars and calculate how much water can be trapped between them. Each time a bar is taller than the top of the stack, it means water can be trapped between the current bar and the one at the top of the stack."
                    }
                ]
            },
            {
                "title": "Problem 4: Largest Rectangle in Histogram",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The **Largest Rectangle in Histogram** problem requires finding the largest rectangle that can be formed within a histogram. This problem can be efficiently solved using a monotonic stack."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def largest_rectangle_area(heights):\n    stack = []\n    max_area = 0\n    heights.append(0)  # Sentinel to ensure the stack is emptied\n    for i in range(len(heights)):\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, h * width)\n        stack.append(i)\n    return max_area\n\n# Test the function\nheights = [2, 1, 5, 6, 2, 3]\nprint(largest_rectangle_area(heights))  # Output: 10"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this problem, we use a stack to maintain the heights of the histogram in increasing order. Whenever we encounter a height that is smaller than the top of the stack, we calculate the possible rectangle's area with the height at the top of the stack."
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we explored the concept of **monotonic stacks** and how they are used to solve problems related to finding the next greater element, daily temperatures, trapping rainwater, and finding the largest rectangle in a histogram. Monotonic stacks are a powerful tool for efficiently solving problems that involve maintaining a relationship between elements in an ordered sequence."
                    }
                ]
            }
        ]
    },
    {
        "title": "Singly Linked Lists",
        "type": "datastructure",
        "difficulty": "medium",
        "duration": "2 hours",
        "lessons": [
            {
                "title": "Introduction to Singly Linked Lists",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **singly linked list** is a linear data structure consisting of nodes. Each node contains two components: a **data** field and a **next** pointer that points to the next node in the sequence. The list terminates when a node\u2019s `next` pointer is `None`."
                    },
                    {
                        "type": "paragraph",
                        "text": "Linked lists differ from arrays in that they do not store data in contiguous memory locations. Instead, they store data in separate nodes, and each node is connected to the next via a pointer. This allows for efficient insertions and deletions but makes random access inefficient compared to arrays."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# A basic structure of a singly linked list node\nclass Node:\n    def __init__(self, data):\n        self.data = data  # Data stored in the node\n        self.next = None  # Pointer to the next node\n\n# Creating a node\na = Node(1)\nb = Node(2)\na.next = b  # Link node a to node b"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we define a `Node` class for the linked list, where each node contains `data` and a pointer to the next node (`next`)."
                    }
                ]
            },
            {
                "title": "Basic Operations on Singly Linked Lists",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The common operations that can be performed on a singly linked list include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Insertion**: Adding a node at the beginning, end, or middle of the list.",
                            "**Deletion**: Removing a node by value or position.",
                            "**Traversal**: Navigating through the list to access nodes.",
                            "**Search**: Finding a node with a specific value."
                        ]
                    }
                ]
            },
            {
                "title": "Insertion into Singly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Insertion can be done at various positions in the list, such as the **head** (beginning), **tail** (end), or in the **middle** of the list."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Class representing the singly linked list\nclass LinkedList:\n    def __init__(self):\n        self.head = None  # Head points to the first node\n\n    # Insert a node at the beginning\n    def insert_at_head(self, data):\n        new_node = Node(data)\n        new_node.next = self.head  # New node points to the current head\n        self.head = new_node  # Update head to the new node\n\n    # Insert a node at the end\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:  # Traverse to the last node\n            temp = temp.next\n        temp.next = new_node  # Link the last node to the new node"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this code, we define two methods for inserting nodes: `insert_at_head()` to insert at the beginning and `insert_at_tail()` to insert at the end of the list."
                    }
                ]
            },
            {
                "title": "Traversal of a Singly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Traversal involves visiting each node in the linked list, starting from the head and moving towards the last node. Traversing a linked list is often necessary for printing or searching the list."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:\n            temp = temp.next\n        temp.next = new_node\n\n    # Method to traverse the linked list\n    def traverse(self):\n        temp = self.head\n        while temp:\n            print(temp.data, end=' -> ')\n            temp = temp.next\n        print('None')\n\n# Test the traversal method\nll = LinkedList()\nll.insert_at_tail(1)\nll.insert_at_tail(2)\nll.insert_at_tail(3)\nll.traverse()  # Output: 1 -> 2 -> 3 -> None"
                    },
                    {
                        "type": "paragraph",
                        "text": "The `traverse()` method visits each node in the list and prints its data. The traversal continues until the `next` pointer of a node is `None`, which indicates the end of the list."
                    }
                ]
            },
            {
                "title": "Deletion from a Singly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Nodes can be deleted from the list by **value** or **position**. Deleting a node requires updating the `next` pointer of the previous node to bypass the node being deleted."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:\n            temp = temp.next\n        temp.next = new_node\n\n    # Method to delete a node by value\n    def delete_by_value(self, key):\n        temp = self.head\n\n        # If the head node itself holds the key\n        if temp and temp.data == key:\n            self.head = temp.next  # Move head to next node\n            temp = None\n            return\n\n        # Search for the node to be deleted\n        prev = None\n        while temp and temp.data != key:\n            prev = temp\n            temp = temp.next\n\n        # If the key was not found in the list\n        if temp is None:\n            return\n\n        # Unlink the node from the list\n        prev.next = temp.next\n        temp = None\n\n# Test the deletion method\nll = LinkedList()\nll.insert_at_tail(1)\nll.insert_at_tail(2)\nll.insert_at_tail(3)\nll.traverse()  # Output: 1 -> 2 -> 3 -> None\nll.delete_by_value(2)\nll.traverse()  # Output: 1 -> 3 -> None"
                    },
                    {
                        "type": "paragraph",
                        "text": "In the `delete_by_value()` method, we search for the node containing the specified value, then unlink it from the list by updating the `next` pointer of the previous node."
                    }
                ]
            },
            {
                "title": "Reversing a Singly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Reversing a singly linked list involves reversing the direction of the pointers, such that the last node becomes the head, and the head becomes the last node."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:\n            temp = temp.next\n        temp.next = new_node\n\n    def traverse(self):\n        temp = self.head\n        while temp:\n            print(temp.data, end=' -> ')\n            temp = temp.next\n        print('None')\n\n    # Method to reverse the linked list\n    def reverse(self):\n        prev = None\n        current = self.head\n        while current:\n            next_node = current.next  # Store the next node\n            current.next = prev  # Reverse the current node's pointer\n            prev = current  # Move the prev pointer forward\n            current = next_node  # Move to the next node\n        self.head = prev  # Update the head to the new first node\n\n# Test the reverse method\nll = LinkedList()\nll.insert_at_tail(1)\nll.insert_at_tail(2)\nll.insert_at_tail(3)\nll.traverse()  # Output: 1 -> 2 -> 3 -> None\nll.reverse()\nll.traverse()  # Output: 3 -> 2 -> 1 -> None"
                    },
                    {
                        "type": "paragraph",
                        "text": "In the `reverse()` method, we iterate through the list and reverse the direction of the pointers. The `prev` pointer is used to keep track of the previous node, and the `current` pointer moves forward through the list."
                    }
                ]
            },
            {
                "title": "Search in a Singly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To search for a value in a singly linked list, we need to traverse the list from the head and compare each node\u2019s data with the target value."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:\n            temp = temp.next\n        temp.next = new_node\n\n    # Method to search for a value in the list\n    def search(self, key):\n        temp = self.head\n        while temp:\n            if temp.data == key:\n                return True\n            temp = temp.next\n        return False\n\n# Test the search method\nll = LinkedList()\nll.insert_at_tail(1)\nll.insert_at_tail(2)\nll.insert_at_tail(3)\nprint(ll.search(2))  # Output: True\nprint(ll.search(4))  # Output: False"
                    },
                    {
                        "type": "paragraph",
                        "text": "The `search()` method iterates through the list and returns `True` if the key is found, and `False` otherwise."
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we covered the fundamentals of **singly linked lists**, including how to insert, traverse, delete, reverse, and search through a linked list. Singly linked lists provide efficient insertion and deletion operations, especially at the head and tail, and are widely used in various data structures and algorithms."
                    }
                ]
            }
        ]
    },
    {
        "title": "Doubly Linked Lists",
        "type": "datastructure",
        "difficulty": "medium",
        "duration": "2 hours",
        "lessons": [
            {
                "title": "Introduction to Doubly Linked Lists",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **doubly linked list** is a linear data structure consisting of nodes, where each node contains three components: a **data** field, a **next** pointer that points to the next node, and a **prev** pointer that points to the previous node. This allows traversal of the list in both directions."
                    },
                    {
                        "type": "paragraph",
                        "text": "Unlike a singly linked list, where nodes only point to the next node, in a doubly linked list, nodes maintain links to both their previous and next neighbors. This makes certain operations, like deletion and backward traversal, more efficient."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# A basic structure of a doubly linked list node\nclass Node:\n    def __init__(self, data):\n        self.data = data  # Data stored in the node\n        self.next = None  # Pointer to the next node\n        self.prev = None  # Pointer to the previous node\n\n# Creating a doubly linked list node\na = Node(1)\nb = Node(2)\na.next = b  # Link node a to node b\nb.prev = a  # Link node b back to node a"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we define a `Node` class for the doubly linked list, where each node contains `data`, a pointer to the `next` node, and a pointer to the `prev` node."
                    }
                ]
            },
            {
                "title": "Basic Operations on Doubly Linked Lists",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Common operations that can be performed on a doubly linked list include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Insertion**: Adding a node at the beginning, end, or middle of the list.",
                            "**Deletion**: Removing a node by value or position.",
                            "**Traversal**: Navigating through the list both forwards and backwards.",
                            "**Search**: Finding a node with a specific value."
                        ]
                    }
                ]
            },
            {
                "title": "Insertion into a Doubly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Insertion into a doubly linked list can be done at various positions such as the **head** (beginning) or **tail** (end), or between two nodes in the **middle** of the list."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Class representing the doubly linked list\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None  # Head points to the first node\n\n    # Insert a node at the beginning\n    def insert_at_head(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n        else:\n            new_node.next = self.head\n            self.head.prev = new_node\n            self.head = new_node\n\n    # Insert a node at the end\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:\n            temp = temp.next\n        temp.next = new_node\n        new_node.prev = temp"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this code, we define two methods for inserting nodes: `insert_at_head()` to insert at the beginning and `insert_at_tail()` to insert at the end of the list. Notice how both `next` and `prev` pointers are adjusted when inserting a node."
                    }
                ]
            },
            {
                "title": "Forward Traversal of a Doubly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Traversing a doubly linked list is similar to a singly linked list, but you can traverse in both directions. Here\u2019s how to perform **forward traversal** from the head to the tail."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:\n            temp = temp.next\n        temp.next = new_node\n        new_node.prev = temp\n\n    # Method to traverse the list forward\n    def traverse_forward(self):\n        temp = self.head\n        while temp:\n            print(temp.data, end=' -> ')\n            temp = temp.next\n        print('None')\n\n# Test the forward traversal method\ndll = DoublyLinkedList()\ndll.insert_at_tail(1)\ndll.insert_at_tail(2)\ndll.insert_at_tail(3)\ndll.traverse_forward()  # Output: 1 -> 2 -> 3 -> None"
                    },
                    {
                        "type": "paragraph",
                        "text": "The `traverse_forward()` method iterates through the list, starting from the head, and prints the data in each node until the end of the list."
                    }
                ]
            },
            {
                "title": "Backward Traversal of a Doubly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Since doubly linked lists have pointers to both the next and previous nodes, we can also traverse the list **backwards**, starting from the tail and moving towards the head."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:\n            temp = temp.next\n        temp.next = new_node\n        new_node.prev = temp\n\n    # Method to traverse the list backward\n    def traverse_backward(self):\n        temp = self.head\n        if not temp:\n            return\n        while temp.next:\n            temp = temp.next  # Go to the last node\n        while temp:\n            print(temp.data, end=' -> ')\n            temp = temp.prev\n        print('None')\n\n# Test the backward traversal method\ndll = DoublyLinkedList()\ndll.insert_at_tail(1)\ndll.insert_at_tail(2)\ndll.insert_at_tail(3)\ndll.traverse_backward()  # Output: 3 -> 2 -> 1 -> None"
                    },
                    {
                        "type": "paragraph",
                        "text": "The `traverse_backward()` method starts from the last node (tail) and moves backward, printing the data of each node."
                    }
                ]
            },
            {
                "title": "Deletion from a Doubly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Nodes in a doubly linked list can be deleted by updating the `prev` and `next` pointers of the neighboring nodes. This makes deletion more efficient since you have access to both previous and next nodes."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:\n            temp = temp.next\n        temp.next = new_node\n        new_node.prev = temp\n\n    # Method to delete a node by value\n    def delete_by_value(self, key):\n        temp = self.head\n\n        # If the head node itself holds the key\n        if temp and temp.data == key:\n            self.head = temp.next\n            if self.head:\n                self.head.prev = None\n            temp = None\n            return\n\n        # Search for the node to be deleted\n        while temp and temp.data != key:\n            temp = temp.next\n\n        if temp is None:\n            return\n\n        # Unlink the node\n        if temp.next:\n            temp.next.prev = temp.prev\n        if temp.prev:\n            temp.prev.next = temp.next\n        temp = None\n\n# Test the deletion method\ndll = DoublyLinkedList()\ndll.insert_at_tail(1)\ndll.insert_at_tail(2)\ndll.insert_at_tail(3)\ndll.traverse_forward()  # Output: 1 -> 2 -> 3 -> None\ndll.delete_by_value(2)\ndll.traverse_forward()  # Output: 1 -> 3 -> None"
                    },
                    {
                        "type": "paragraph",
                        "text": "In the `delete_by_value()` method, we update the `next` pointer of the previous node and the `prev` pointer of the next node to bypass the node being deleted."
                    }
                ]
            },
            {
                "title": "Reversing a Doubly Linked List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Reversing a doubly linked list involves swapping the `next` and `prev` pointers of each node and then updating the head to point to the new first node."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert_at_tail(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        temp = self.head\n        while temp.next:\n            temp = temp.next\n        temp.next = new_node\n        new_node.prev = temp\n\n    def traverse_forward(self):\n        temp = self.head\n        while temp:\n            print(temp.data, end=' -> ')\n            temp = temp.next\n        print('None')\n\n    # Method to reverse the doubly linked list\n    def reverse(self):\n        temp = None\n        current = self.head\n\n        # Swap next and prev for all nodes\n        while current:\n            temp = current.prev\n            current.prev = current.next\n            current.next = temp\n            current = current.prev\n\n        # Update the head to point to the new first node\n        if temp:\n            self.head = temp.prev\n\n# Test the reverse method\ndll = DoublyLinkedList()\ndll.insert_at_tail(1)\ndll.insert_at_tail(2)\ndll.insert_at_tail(3)\ndll.traverse_forward()  # Output: 1 -> 2 -> 3 -> None\ndll.reverse()\ndll.traverse_forward()  # Output: 3 -> 2 -> 1 -> None"
                    },
                    {
                        "type": "paragraph",
                        "text": "In the `reverse()` method, we iterate through the list and swap the `next` and `prev` pointers of each node. Finally, we update the head to point to the new first node."
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we explored the **doubly linked list** data structure, including how to insert, traverse (both forward and backward), delete, and reverse nodes in the list. Doubly linked lists provide greater flexibility than singly linked lists due to the ability to traverse in both directions, making them more efficient for certain operations like deletion."
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Search",
        "type": "algorithm",
        "difficulty": "medium",
        "duration": "1 hour",
        "lessons": [
            {
                "title": "Introduction to Binary Search",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "**Binary Search** is an efficient algorithm for finding an element in a sorted array. It works by repeatedly dividing the search interval in half. If the target value is less than the middle element, the search continues in the lower half; otherwise, it continues in the upper half."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Time Complexity**: O(log n), because the array is halved at each step.",
                            "**Requirement**: The array (or list) must be sorted."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "Binary search is much more efficient than linear search (O(n)) for large datasets, as it reduces the problem size significantly at each step."
                    }
                ]
            },
            {
                "title": "Binary Search Algorithm",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The binary search algorithm follows these steps:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Set two pointers, `low` and `high`, at the start and end of the array.",
                            "Calculate the middle index: `mid = (low + high) // 2`.",
                            "Compare the middle element with the target value:",
                            "- If the middle element equals the target, return the index.",
                            "- If the target is smaller than the middle element, search the left half (`high = mid - 1`).",
                            "- If the target is larger, search the right half (`low = mid + 1`).",
                            "Repeat until the target is found or `low` exceeds `high`."
                        ]
                    }
                ]
            },
            {
                "title": "Implementing Binary Search (Iterative)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Here\u2019s the implementation of binary search using an **iterative** approach:"
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1  # Target not found\n\n# Usage\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(binary_search(arr, 5))  # Output: 4"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the `binary_search()` function divides the array and checks if the middle element is the target. If not, it adjusts the search range based on whether the target is smaller or larger than the middle element."
                    }
                ]
            },
            {
                "title": "Implementing Binary Search (Recursive)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can also implement binary search using a **recursive** approach. In this case, the function calls itself with adjusted search ranges."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def binary_search_recursive(arr, target, low, high):\n    if low > high:\n        return -1  # Base case: target not found\n\n    mid = (low + high) // 2\n\n    if arr[mid] == target:\n        return mid\n    elif arr[mid] < target:\n        return binary_search_recursive(arr, target, mid + 1, high)\n    else:\n        return binary_search_recursive(arr, target, low, mid - 1)\n\n# Usage\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(binary_search_recursive(arr, 5, 0, len(arr) - 1))  # Output: 4"
                    },
                    {
                        "type": "paragraph",
                        "text": "This recursive implementation of binary search behaves similarly to the iterative one, except that it uses function calls to search the left or right half."
                    }
                ]
            },
            {
                "title": "Handling Edge Cases",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "When using binary search, it's important to handle several edge cases, such as:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Searching an empty array: The function should return `-1`.",
                            "Target not found: Return `-1` after the search interval becomes invalid (`low > high`).",
                            "Duplicate elements: If duplicates exist, binary search will return the index of one occurrence, but may not necessarily return the first or last occurrence."
                        ]
                    }
                ]
            },
            {
                "title": "Variants of Binary Search",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Binary search can be modified for different scenarios, such as finding the first or last occurrence of an element in an array with duplicates, or finding the smallest element greater than the target."
                    }
                ]
            },
            {
                "title": "Finding the First Occurrence of an Element",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To find the **first occurrence** of a target element, modify binary search to continue searching in the left half even after finding the target."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def binary_search_first(arr, target):\n    low, high = 0, len(arr) - 1\n    result = -1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            result = mid\n            high = mid - 1  # Keep searching to the left\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return result  # First occurrence\n\n# Usage\narr = [1, 2, 2, 2, 3, 4, 5]\nprint(binary_search_first(arr, 2))  # Output: 1"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this variant, the algorithm continues searching to the left (`high = mid - 1`) even after finding the target to ensure it finds the first occurrence."
                    }
                ]
            },
            {
                "title": "Advantages of Binary Search",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Efficient with O(log n) time complexity.",
                            "Reduces problem size significantly with each step.",
                            "Works well with large, sorted datasets."
                        ]
                    }
                ]
            },
            {
                "title": "Limitations of Binary Search",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Requires the array to be sorted.",
                            "Inefficient for small datasets compared to linear search."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this lesson, we covered the **Binary Search** algorithm, both iteratively and recursively, and discussed its applications and variations. Binary search is one of the most efficient algorithms for finding elements in sorted datasets and is a fundamental concept in computer science."
                    }
                ]
            }
        ]
    },
    {
        "title": "Sliding Window",
        "type": "concept",
        "difficulty": "medium",
        "duration": "1 hour",
        "lessons": [
            {
                "title": "Introduction to Sliding Window",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The sliding window technique is a common approach to solving problems involving sequences, such as arrays or strings. It is used to maintain a subset of elements from the sequence that 'slides' over it to process a problem more efficiently."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "The sliding window approach is useful for finding subarrays or substrings that meet specific criteria.",
                            "It can be implemented using a fixed-size window or a dynamic window that grows or shrinks as needed.",
                            "This technique reduces the need for nested loops, improving the time complexity in many cases."
                        ]
                    }
                ]
            },
            {
                "title": "Fixed-size Sliding Window",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In the fixed-size sliding window, the window size is predefined, and the window slides over the sequence by adding a new element and removing the oldest element as it progresses."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def max_sum_subarray(arr, k):\n    max_sum = float('-inf')\n    current_sum = sum(arr[:k])\n\n    for i in range(k, len(arr)):\n        current_sum += arr[i] - arr[i - k]\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\narr = [2, 1, 5, 1, 3, 2]\nk = 3\nprint(max_sum_subarray(arr, k))  # Output: 9"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we calculate the maximum sum of a subarray of size `k`. We slide the window by subtracting the element that's left behind and adding the new element. This reduces the time complexity to O(n), compared to a brute-force O(n*k) approach."
                    }
                ]
            },
            {
                "title": "Dynamic-size Sliding Window",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In dynamic-size sliding window problems, the window expands or contracts based on certain conditions. This is commonly used to solve problems that require finding the smallest or largest subarray meeting a condition."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def min_subarray_sum(arr, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n\n    for right in range(len(arr)):\n        current_sum += arr[right]\n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= arr[left]\n            left += 1\n\n    return min_length if min_length != float('inf') else 0\n\narr = [2, 3, 1, 2, 4, 3]\ntarget = 7\nprint(min_subarray_sum(arr, target))  # Output: 2"
                    },
                    {
                        "type": "paragraph",
                        "text": "This example solves the problem of finding the smallest subarray whose sum is greater than or equal to a target value. The window dynamically grows by adding elements, and contracts by moving the left pointer when the condition is met."
                    }
                ]
            },
            {
                "title": "Sliding Window for Strings",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The sliding window technique can also be applied to strings for problems such as finding substrings or determining whether two strings are anagrams."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def find_anagrams(s, p):\n    from collections import Counter\n    p_count = Counter(p)\n    s_count = Counter()\n    result = []\n    left = 0\n\n    for right in range(len(s)):\n        s_count[s[right]] += 1\n        if right >= len(p):\n            if s_count[s[left]] == 1:\n                del s_count[s[left]]\n            else:\n                s_count[s[left]] -= 1\n            left += 1\n        if s_count == p_count:\n            result.append(left)\n\n    return result\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(find_anagrams(s, p))  # Output: [0, 6]"
                    },
                    {
                        "type": "paragraph",
                        "text": "This example finds all the starting indices of anagrams of string `p` in string `s`. The sliding window is used to maintain the frequency count of characters in the current window of `s`, and we compare it with the frequency count of `p`."
                    }
                ]
            },
            {
                "title": "Example: Maximum Sliding Window",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Given an array, the task is to find the maximum value in every sliding window of size `k`. This can be efficiently solved using a deque (double-ended queue) to keep track of the maximum element."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "from collections import deque\n\ndef max_sliding_window(nums, k):\n    dq = deque()\n    result = []\n\n    for i in range(len(nums)):\n        # Remove elements not within the sliding window\n        if dq and dq[0] == i - k:\n            dq.popleft()\n        # Remove smaller elements as they are not useful\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        dq.append(i)\n        # Add the maximum for this window\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n\n    return result\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(max_sliding_window(nums, k))  # Output: [3, 3, 5, 5, 6, 7]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we use a deque to efficiently maintain the indices of the maximum elements within each sliding window. The time complexity is O(n), as each element is added and removed from the deque at most once."
                    }
                ]
            },
            {
                "title": "When to Use Sliding Window",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The sliding window technique is ideal for solving problems where you need to find a subarray or substring that meets a certain condition. It is most effective when the problem can be simplified by considering a window of elements rather than using brute-force nested loops."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Problems involving subarrays or substrings of fixed or variable length.",
                            "Optimization problems that require finding the maximum, minimum, or sum within a subset of the data.",
                            "Problems that involve comparisons or frequency counts over a sequence."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The sliding window technique is a powerful tool for optimizing solutions to problems that involve sequences. Whether working with arrays or strings, using a sliding window allows you to reduce the time complexity by avoiding unnecessary recomputation, making it an essential strategy for efficient problem solving."
                    }
                ]
            }
        ]
    },
    {
        "title": "Recursion",
        "type": "concept",
        "difficulty": "medium",
        "duration": "2 hours",
        "lessons": [
            {
                "title": "Introduction to Recursion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In computer science, **recursion** is a method of solving problems where a function calls itself as a subroutine. This allows the function to be repeated several times, as it can call itself during its execution. A recursive function typically has two parts: the **base case**, which stops the recursion, and the **recursive case**, which continues the recursion."
                    },
                    {
                        "type": "paragraph",
                        "text": "Recursion is commonly used in problems that can be broken down into smaller, similar subproblems, such as tree traversal, divide-and-conquer algorithms, and backtracking."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Basic structure of a recursive function\n\ndef recursive_function(parameters):\n    if base_condition:\n        return base_result  # Base case\n    else:\n        return recursive_function(modified_parameters)  # Recursive case\n"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this general example, the recursive function calls itself until it meets a base case that stops further recursion."
                    }
                ]
            },
            {
                "title": "Factorial Example (Classic Recursion Problem)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The **factorial** of a number `n` is the product of all positive integers less than or equal to `n`. It can be defined recursively as follows:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`factorial(0) = 1` (base case)",
                            "`factorial(n) = n * factorial(n - 1)` (recursive case)"
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def factorial(n):\n    # Base case\n    if n == 0:\n        return 1\n    # Recursive case\n    else:\n        return n * factorial(n - 1)\n\n# Test the factorial function\nprint(factorial(5))  # Output: 120"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the factorial function calls itself with a smaller value (`n - 1`) until it reaches the base case where `n == 0`."
                    }
                ]
            },
            {
                "title": "Understanding Recursion through Tree Traversal",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "One common use of recursion is **tree traversal**. In tree traversal, we recursively visit each node of the tree starting from the root. The two most common types of tree traversals are **in-order** (left, root, right) and **pre-order** (root, left, right)."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n# In-order traversal (left, root, right)\ndef in_order_traversal(root):\n    if root:\n        in_order_traversal(root.left)\n        print(root.data, end=' ')\n        in_order_traversal(root.right)\n\n# Pre-order traversal (root, left, right)\ndef pre_order_traversal(root):\n    if root:\n        print(root.data, end=' ')\n        pre_order_traversal(root.left)\n        pre_order_traversal(root.right)\n\n# Creating a sample binary tree\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\n\n# Test the in-order and pre-order traversals\nin_order_traversal(root)  # Output: 4 2 5 1 3\npre_order_traversal(root)  # Output: 1 2 4 5 3"
                    },
                    {
                        "type": "paragraph",
                        "text": "In these recursive tree traversal functions, the function calls itself on the left and right subtrees. The base case is when the `root` is `None`, meaning we\u2019ve reached the end of a branch."
                    }
                ]
            },
            {
                "title": "Recursion vs. Iteration",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Recursion and iteration are two techniques used to solve repetitive problems. Recursion often leads to cleaner, simpler code but can be less efficient than iteration due to the overhead of function calls. Let's compare the two by implementing the same problem using both recursion and iteration."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Factorial using recursion\ndef factorial_recursive(n):\n    if n == 0:\n        return 1\n    return n * factorial_recursive(n - 1)\n\n# Factorial using iteration\ndef factorial_iterative(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\n# Test both methods\nprint(factorial_recursive(5))  # Output: 120\nprint(factorial_iterative(5))  # Output: 120"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, both the recursive and iterative implementations of the factorial function produce the same result. However, the iterative version may be more efficient for larger inputs, as it avoids the overhead of recursive function calls."
                    }
                ]
            },
            {
                "title": "Common Problems Solved Using Recursion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Recursion is particularly well-suited for problems that can be divided into smaller subproblems. Some classic problems that are solved using recursion include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Fibonacci sequence**: Computing the nth Fibonacci number using recursion.",
                            "**Merge sort**: A divide-and-conquer algorithm that recursively splits and merges arrays.",
                            "**Tower of Hanoi**: A puzzle that requires moving disks between rods while maintaining certain rules.",
                            "**Permutations and combinations**: Generating all permutations or combinations of a given set."
                        ]
                    }
                ]
            },
            {
                "title": "Fibonacci Sequence (Recursive Example)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The **Fibonacci sequence** is a sequence of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. The recursive definition of the Fibonacci sequence is:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`fibonacci(0) = 0` (base case)",
                            "`fibonacci(1) = 1` (base case)",
                            "`fibonacci(n) = fibonacci(n - 1) + fibonacci(n - 2)` (recursive case)"
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\n# Test the Fibonacci function\nprint(fibonacci(6))  # Output: 8"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this recursive Fibonacci function, the base cases handle `n == 0` and `n == 1`, and the recursive case calculates the Fibonacci number for `n` by summing the two previous Fibonacci numbers."
                    }
                ]
            },
            {
                "title": "Backtracking (Another Recursive Technique)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "**Backtracking** is a recursive technique used to solve constraint satisfaction problems. It builds a solution incrementally, one step at a time, and removes solutions that do not meet the conditions (known as pruning). Problems like the **N-Queens Problem** and **finding all subsets** can be solved using backtracking."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Example: Finding all subsets using backtracking\n\ndef find_subsets(nums):\n    result = []\n\n    def backtrack(start, path):\n        result.append(path)\n        for i in range(start, len(nums)):\n            backtrack(i + 1, path + [nums[i]])\n\n    backtrack(0, [])\n    return result\n\n# Test the find_subsets function\nnums = [1, 2, 3]\nprint(find_subsets(nums))  # Output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this backtracking example, we use recursion to generate all possible subsets of a list of numbers. Each recursive call explores a different path (subset), and if the path is valid, it is added to the result."
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we explored the concept of **recursion**, learned how to write recursive functions, and examined common problems that can be solved using recursion. Although recursion simplifies many problems, it is essential to understand its limitations, such as stack overflow and performance overhead."
                    }
                ]
            }
        ]
    },
    {
        "title": "Backtracking",
        "type": "concept",
        "difficulty": "hard",
        "duration": "2 hours",
        "lessons": [
            {
                "title": "Introduction to Backtracking",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Backtracking is a general algorithm for solving problems incrementally, where a candidate solution is built step-by-step, and abandoned ('backtracked') as soon as it is determined that the candidate cannot lead to a valid solution."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Backtracking is used for problems involving combinatorial optimization, like finding all subsets, permutations, or solving puzzles.",
                            "It is often described as a depth-first search approach.",
                            "A key feature is 'pruning'\u2014cutting off parts of the search tree that don't lead to a valid solution."
                        ]
                    }
                ]
            },
            {
                "title": "Common Problems Solved Using Backtracking",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "N-Queens Problem",
                            "Sudoku Solver",
                            "Word Search",
                            "Permutations and Combinations",
                            "Subset Sum Problem"
                        ]
                    }
                ]
            },
            {
                "title": "The Backtracking Algorithm",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The basic idea of backtracking is to build a solution incrementally and remove or backtrack as soon as we determine that the current partial solution cannot be completed to a valid solution."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def backtrack(candidate):\n    if is_solution(candidate):\n        output(candidate)\n    else:\n        for next_candidate in make_candidates(candidate):\n            if is_valid(next_candidate):\n                backtrack(next_candidate)"
                    },
                    {
                        "type": "paragraph",
                        "text": "The key steps are checking if the current candidate is a valid solution, generating possible next steps, and checking if each step is valid."
                    }
                ]
            },
            {
                "title": "Example: N-Queens Problem",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The N-Queens problem asks for ways to place N queens on an N\u00d7N chessboard so that no two queens threaten each other. Backtracking can be used to explore all possible arrangements and prune invalid placements early."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def solve_n_queens(n):\n    def is_valid(board, row, col):\n        for i in range(row):\n            if board[i] == col or abs(board[i] - col) == row - i:\n                return False\n        return True\n\n    def place_queen(board, row):\n        if row == n:\n            solutions.append(board[:])\n        else:\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row] = col\n                    place_queen(board, row + 1)\n                    board[row] = -1\n\n    solutions = []\n    place_queen([-1] * n, 0)\n    return solutions"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we place one queen at a time and backtrack if placing the current queen leads to an invalid arrangement."
                    }
                ]
            },
            {
                "title": "Pruning the Search Tree",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Pruning is essential in backtracking to reduce the search space. For example, in the N-Queens problem, we avoid placing a queen in the same column or diagonal as a previous queen."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def is_valid(board, row, col):\n    for i in range(row):\n        if board[i] == col or abs(board[i] - col) == row - i:\n            return False\n    return True"
                    },
                    {
                        "type": "paragraph",
                        "text": "By adding this check, we ensure that the algorithm stops exploring invalid arrangements as early as possible."
                    }
                ]
            },
            {
                "title": "Advantages and Disadvantages of Backtracking",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Advantages: Simple to implement, can handle a wide variety of problems, can find all possible solutions.",
                            "Disadvantages: Can be slow if the problem space is large, performance depends on the pruning strategy."
                        ]
                    }
                ]
            },
            {
                "title": "Optimizations for Backtracking",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Certain strategies can make backtracking more efficient, such as using heuristics to choose the next candidate or memoization to avoid recalculating the same result."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Example of using memoization in backtracking\nmemo = {}\ndef backtrack_with_memo(candidate):\n    if candidate in memo:\n        return memo[candidate]\n    # Continue with the rest of the backtracking logic"
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Backtracking is a powerful technique for solving constraint satisfaction problems. While it can be slow, effective pruning and optimizations can dramatically improve its performance."
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Trees",
        "type": "datastructure",
        "difficulty": "medium",
        "duration": "2 hours",
        "lessons": [
            {
                "title": "Introduction to Binary Trees",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **binary tree** is a hierarchical data structure in which each node has at most two children, referred to as the **left child** and the **right child**. Binary trees are widely used in various algorithms and applications, such as expression parsing, searching, and hierarchical data modeling."
                    },
                    {
                        "type": "paragraph",
                        "text": "Binary trees do not follow the rules of binary search trees (BSTs), where nodes are arranged based on specific values. In binary trees, there are no value-based constraints; instead, the focus is on the hierarchical structure."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Basic structure of a binary tree node\nclass Node:\n    def __init__(self, data):\n        self.data = data  # Store node data\n        self.left = None  # Pointer to left child\n        self.right = None  # Pointer to right child\n\n# Creating a sample binary tree\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we define a `Node` class representing each node of the binary tree. The binary tree is built by manually linking nodes together."
                    }
                ]
            },
            {
                "title": "Types of Binary Trees",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "There are various types of binary trees, each with unique characteristics:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Full Binary Tree**: Every node has either 0 or 2 children.",
                            "**Complete Binary Tree**: All levels, except possibly the last, are fully filled, and all nodes are as far left as possible.",
                            "**Perfect Binary Tree**: All internal nodes have two children, and all leaf nodes are at the same level.",
                            "**Balanced Binary Tree**: The height of the left and right subtrees of any node differ by at most 1."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "Different types of binary trees are used based on specific problem requirements, and their structure affects the efficiency of operations such as traversal and insertion."
                    }
                ]
            },
            {
                "title": "Tree Traversal (In-order, Pre-order, and Post-order)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Traversing a binary tree means visiting all its nodes in a particular order. The most common traversal methods are **in-order**, **pre-order**, and **post-order**."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**In-order (Left, Root, Right)**: Visit the left subtree, then the root node, then the right subtree.",
                            "**Pre-order (Root, Left, Right)**: Visit the root node, then the left subtree, then the right subtree.",
                            "**Post-order (Left, Right, Root)**: Visit the left subtree, then the right subtree, then the root node."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# In-order traversal (Left, Root, Right)\ndef in_order_traversal(root):\n    if root:\n        in_order_traversal(root.left)\n        print(root.data, end=' ')\n        in_order_traversal(root.right)\n\n# Pre-order traversal (Root, Left, Right)\ndef pre_order_traversal(root):\n    if root:\n        print(root.data, end=' ')\n        pre_order_traversal(root.left)\n        pre_order_traversal(root.right)\n\n# Post-order traversal (Left, Right, Root)\ndef post_order_traversal(root):\n    if root:\n        post_order_traversal(root.left)\n        post_order_traversal(root.right)\n        print(root.data, end=' ')\n\n# Test the traversals\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n\nprint('In-order traversal:')\nin_order_traversal(root)  # Output: 4 2 5 1 6 3 7\n\nprint('\\nPre-order traversal:')\npre_order_traversal(root)  # Output: 1 2 4 5 3 6 7\n\nprint('\\nPost-order traversal:')\npost_order_traversal(root)  # Output: 4 5 2 6 7 3 1"
                    },
                    {
                        "type": "paragraph",
                        "text": "Each traversal method visits the nodes in a different order, depending on when the root, left subtree, and right subtree are visited."
                    }
                ]
            },
            {
                "title": "Level-order Traversal (Breadth-First Search)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In **level-order traversal** (also known as breadth-first search), we visit the nodes of the binary tree level by level, starting from the root. This can be implemented using a queue."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "from collections import deque\n\ndef level_order_traversal(root):\n    if not root:\n        return\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        print(node.data, end=' ')\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n\n# Test the level-order traversal\nprint('\\nLevel-order traversal:')\nlevel_order_traversal(root)  # Output: 1 2 3 4 5 6 7"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the binary tree is traversed level by level using a queue. The `popleft()` operation ensures that nodes are processed in the order they are added to the queue."
                    }
                ]
            },
            {
                "title": "Height of a Binary Tree",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The **height of a binary tree** is the number of edges on the longest path from the root node to a leaf node. The height of an empty tree is considered -1."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Method to find the height of the binary tree\ndef height_of_tree(root):\n    if root is None:\n        return -1  # Base case: empty tree has height -1\n    else:\n        left_height = height_of_tree(root.left)\n        right_height = height_of_tree(root.right)\n        return max(left_height, right_height) + 1\n\n# Test the height of the binary tree\nprint('\\nHeight of tree:', height_of_tree(root))  # Output: 2"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this recursive method, we calculate the height of both the left and right subtrees and return the maximum of the two, plus one to account for the current node."
                    }
                ]
            },
            {
                "title": "Counting Nodes in a Binary Tree",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "We can recursively count the total number of nodes in a binary tree by counting the nodes in the left subtree, the nodes in the right subtree, and then adding one for the root node."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Method to count the total number of nodes\ndef count_nodes(root):\n    if root is None:\n        return 0\n    return 1 + count_nodes(root.left) + count_nodes(root.right)\n\n# Test the node counting method\nprint('\\nTotal number of nodes:', count_nodes(root))  # Output: 7"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this method, we count the nodes in the left and right subtrees recursively and add one for the root node."
                    }
                ]
            },
            {
                "title": "Binary Tree Use Cases",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Binary trees are used in various real-world applications due to their hierarchical structure and efficient traversal properties. Some common use cases include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Expression Trees**: Representing arithmetic expressions where internal nodes are operators and leaf nodes are operands.",
                            "**File System Hierarchies**: Storing directories and files in a hierarchical manner.",
                            "**Decision Trees**: Used in machine learning for classification and decision-making.",
                            "**Game Trees**: Representing possible moves in games like chess or tic-tac-toe."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we explored **binary trees**, covering different traversal techniques (in-order, pre-order, post-order, and level-order), how to calculate the height of a tree, and how to count the number of nodes. Binary trees are a fundamental data structure with numerous applications in computer science."
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Search Trees",
        "type": "datastructure",
        "difficulty": "medium",
        "duration": "1 hour",
        "lessons": [
            {
                "title": "Introduction to Binary Search Trees",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **Binary Search Tree (BST)** is a special type of binary tree where the nodes are arranged in a specific order: for any given node, its left subtree contains nodes with values less than the node's value, and its right subtree contains nodes with values greater than the node's value. This property makes searching, insertion, and deletion operations more efficient compared to a regular binary tree."
                    },
                    {
                        "type": "paragraph",
                        "text": "The key characteristic of a BST is that it allows for efficient searching, insertion, and deletion operations with a time complexity of **O(log n)** in the average case. However, in the worst case (e.g., if the tree is unbalanced), the time complexity can degrade to **O(n)**."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Basic structure of a binary search tree node\nclass Node:\n    def __init__(self, data):\n        self.data = data  # Node value\n        self.left = None  # Pointer to left child\n        self.right = None  # Pointer to right child\n\n# Inserting a node into a BST\ndef insert(root, data):\n    if root is None:\n        return Node(data)\n    if data < root.data:\n        root.left = insert(root.left, data)\n    else:\n        root.right = insert(root.right, data)\n    return root\n\n# Creating a BST and inserting nodes\nroot = Node(10)\ninsert(root, 5)\ninsert(root, 15)\ninsert(root, 3)\ninsert(root, 7)\ninsert(root, 12)\ninsert(root, 17)"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we define a `Node` class for the binary search tree and a recursive `insert()` function to add nodes to the BST. The function inserts the node in the correct position based on the value."
                    }
                ]
            },
            {
                "title": "Searching in a Binary Search Tree",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Searching for a value in a binary search tree is efficient because we can compare the value with the current node and decide whether to search in the left or right subtree. This reduces the search space by half with each step."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Searching for a value in a BST\ndef search(root, key):\n    if root is None or root.data == key:\n        return root\n    if key < root.data:\n        return search(root.left, key)\n    return search(root.right, key)\n\n# Test the search method\nresult = search(root, 7)\nif result:\n    print(f'Node found: {result.data}')  # Output: Node found: 7\nelse:\n    print('Node not found')"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this recursive `search()` function, we start from the root and compare the value with the current node. If the value matches, we return the node; otherwise, we search the left or right subtree based on whether the value is smaller or larger."
                    }
                ]
            },
            {
                "title": "In-order Traversal of a Binary Search Tree",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "**In-order traversal** of a binary search tree visits the nodes in **ascending order**. This is because the left subtree contains smaller values, the root contains the middle value, and the right subtree contains larger values."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# In-order traversal of a BST (Left, Root, Right)\ndef in_order_traversal(root):\n    if root:\n        in_order_traversal(root.left)\n        print(root.data, end=' ')\n        in_order_traversal(root.right)\n\n# Test the in-order traversal\nprint('In-order traversal:')\nin_order_traversal(root)  # Output: 3 5 7 10 12 15 17"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this `in_order_traversal()` function, we recursively visit the left subtree, then the root node, and finally the right subtree. This results in a sorted order for the node values."
                    }
                ]
            },
            {
                "title": "Deleting a Node from a Binary Search Tree",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Deleting a node from a binary search tree is a bit more complex, as it depends on whether the node to be deleted has 0, 1, or 2 children:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "If the node has no children (a leaf node), simply remove it.",
                            "If the node has one child, remove it and connect its child to its parent.",
                            "If the node has two children, replace the node with its **in-order successor** (the smallest value in its right subtree) or **in-order predecessor** (the largest value in its left subtree)."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Deleting a node from a BST\ndef delete_node(root, key):\n    if root is None:\n        return root\n    if key < root.data:\n        root.left = delete_node(root.left, key)\n    elif key > root.data:\n        root.right = delete_node(root.right, key)\n    else:\n        # Node with only one child or no child\n        if root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        # Node with two children: Get the inorder successor (smallest in the right subtree)\n        temp = find_min(root.right)\n        root.data = temp.data\n        root.right = delete_node(root.right, temp.data)\n    return root\n\n# Find the minimum value in a subtree\ndef find_min(node):\n    current = node\n    while current.left is not None:\n        current = current.left\n    return current\n\n# Test deleting a node\nroot = delete_node(root, 5)\nin_order_traversal(root)  # Output after deletion: 3 7 10 12 15 17"
                    },
                    {
                        "type": "paragraph",
                        "text": "In the `delete_node()` function, we recursively search for the node to delete. Depending on the number of children, we handle the deletion accordingly. If the node has two children, we replace it with its in-order successor."
                    }
                ]
            },
            {
                "title": "Finding the Minimum and Maximum Values",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In a binary search tree, the **minimum value** is found by traversing to the leftmost node, while the **maximum value** is found by traversing to the rightmost node."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Finding the minimum value in a BST\ndef find_min(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current.data\n\n# Finding the maximum value in a BST\ndef find_max(root):\n    current = root\n    while current.right is not None:\n        current = current.right\n    return current.data\n\n# Test finding minimum and maximum values\nprint('Minimum value:', find_min(root))  # Output: 3\nprint('Maximum value:', find_max(root))  # Output: 17"
                    },
                    {
                        "type": "paragraph",
                        "text": "To find the minimum value, we keep traversing left until we reach the leftmost node. To find the maximum value, we traverse right until we reach the rightmost node."
                    }
                ]
            },
            {
                "title": "Balancing a Binary Search Tree",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Binary search trees can become unbalanced, degrading their performance to **O(n)** for certain operations. To maintain optimal performance, balanced trees such as **AVL trees** or **Red-Black trees** are used. These trees automatically balance themselves during insertion and deletion."
                    },
                    {
                        "type": "paragraph",
                        "text": "Although balancing techniques are beyond the scope of this tutorial, understanding that an unbalanced binary search tree can become inefficient is important. Algorithms like **AVL rotation** and **Red-Black balancing** help maintain a balanced structure."
                    }
                ]
            },
            {
                "title": "Binary Search Tree Use Cases",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Binary search trees are widely used in various applications where fast searching, insertion, and deletion are required. Some common use cases include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Databases**: BSTs are used in indexing to optimize search queries.",
                            "**File Systems**: Directory management can use BSTs to organize files.",
                            "**Autocomplete Systems**: Maintaining a dictionary of words to provide suggestions quickly.",
                            "**In-memory Data Structures**: BSTs are used in caching and lookups where ordered data is needed."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we explored the **binary search tree (BST)**, covering how to insert, search, delete, and traverse nodes in the tree. Binary search trees are an efficient data structure for managing ordered data, but they can become inefficient if unbalanced. By ensuring balance, we can maintain optimal performance for common operations."
                    }
                ]
            }
        ]
    },
    {
        "title": "Tries",
        "type": "datastructure",
        "difficulty": "hard",
        "duration": "1.5 hours",
        "lessons": [
            {
                "title": "Introduction to Tries",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A Trie (pronounced as 'try') is a tree-like data structure used to store a dynamic set of strings, where each node represents a single character of a string. It is commonly used for prefix matching, autocomplete systems, and dictionary-like lookups."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Each node represents a single character.",
                            "A Trie supports efficient prefix lookups, making it ideal for autocomplete systems.",
                            "Tries are space-efficient for storing a large number of related strings."
                        ]
                    }
                ]
            },
            {
                "title": "Trie Node Structure",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Each node in a Trie contains a dictionary to hold child nodes and a boolean flag to indicate whether the node represents the end of a word."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this `TrieNode` class, `children` is a dictionary that stores child nodes, and `is_end_of_word` indicates whether the node marks the end of a complete word."
                    }
                ]
            },
            {
                "title": "Trie Structure",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The `Trie` class manages the root node of the Trie and provides methods to insert words, search for words, and check for prefixes."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "class Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True"
                    },
                    {
                        "type": "paragraph",
                        "text": "In the `Trie` class, the `insert()` method adds a word to the Trie by traversing or creating nodes for each character in the word."
                    }
                ]
            },
            {
                "title": "Inserting Words into a Trie",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To insert a word into a Trie, traverse the Trie by following or creating nodes for each character in the word. Mark the end of the word by setting the `is_end_of_word` flag to `True`."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "trie = Trie()\ntrie.insert('apple')\ntrie.insert('app')\ntrie.insert('apex')\n# The Trie now contains the words 'apple', 'app', and 'apex'"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the words 'apple', 'app', and 'apex' are inserted into the Trie. Each word shares common prefixes, making the Trie space-efficient."
                    }
                ]
            },
            {
                "title": "Searching for Words in a Trie",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To search for a word in a Trie, traverse the Trie following the nodes for each character in the word. If the word exists, you should reach a node where `is_end_of_word` is `True`."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def search(self, word):\n    node = self.root\n    for char in word:\n        if char not in node.children:\n            return False\n        node = node.children[char]\n    return node.is_end_of_word"
                    },
                    {
                        "type": "paragraph",
                        "text": "This `search()` method checks whether a given word exists in the Trie by traversing the nodes for each character. It returns `True` if the word exists and `False` otherwise."
                    }
                ]
            },
            {
                "title": "Prefix Search in a Trie",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A Trie is particularly useful for prefix searches. To check if a given prefix exists in the Trie, traverse the nodes of the prefix without checking the `is_end_of_word` flag."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def starts_with(self, prefix):\n    node = self.root\n    for char in prefix:\n        if char not in node.children:\n            return False\n        node = node.children[char]\n    return True"
                    },
                    {
                        "type": "paragraph",
                        "text": "This `starts_with()` method checks whether a given prefix exists in the Trie by traversing the nodes for each character in the prefix."
                    }
                ]
            },
            {
                "title": "Autocomplete Using a Trie",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "One of the most common uses of a Trie is to provide autocomplete suggestions. After checking if a prefix exists in the Trie, you can recursively find all words that begin with that prefix."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def autocomplete(self, prefix):\n    def dfs(node, prefix, result):\n        if node.is_end_of_word:\n            result.append(prefix)\n        for char, child in node.children.items():\n            dfs(child, prefix + char, result)\n\n    node = self.root\n    for char in prefix:\n        if char not in node.children:\n            return []\n        node = node.children[char]\n\n    result = []\n    dfs(node, prefix, result)\n    return result"
                    },
                    {
                        "type": "paragraph",
                        "text": "This `autocomplete()` method finds all words in the Trie that start with a given prefix using a depth-first search (DFS) on the Trie from the last node of the prefix."
                    }
                ]
            },
            {
                "title": "Deleting Words from a Trie",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Deleting a word from a Trie involves traversing the Trie to find the word, then unmarking the `is_end_of_word` flag. If nodes become unnecessary (no longer shared by other words), they should be removed."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def delete(self, word):\n    def _delete(node, word, depth):\n        if not node:\n            return False\n        if depth == len(word):\n            if not node.is_end_of_word:\n                return False\n            node.is_end_of_word = False\n            return len(node.children) == 0\n        char = word[depth]\n        if char in node.children and _delete(node.children[char], word, depth + 1):\n            del node.children[char]\n            return len(node.children) == 0\n        return False\n\n    _delete(self.root, word, 0)"
                    },
                    {
                        "type": "paragraph",
                        "text": "This `delete()` method recursively finds and removes the word from the Trie. It removes nodes that are no longer part of any other words in the Trie."
                    }
                ]
            },
            {
                "title": "Trie Use Cases",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Tries are widely used in applications where fast retrieval of strings is required, such as:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Autocomplete systems (e.g., search engine suggestions).",
                            "Spell checkers (quickly finding words with a given prefix).",
                            "IP routing (where prefixes of IP addresses are used to determine routing paths).",
                            "Dictionary or lexicon storage for quick lookups."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we covered the basics of Tries, including how to insert, search, and delete words, as well as perform prefix searches and autocomplete. Tries are a powerful data structure for efficiently managing and querying strings with shared prefixes."
                    }
                ]
            }
        ]
    },
    {
        "title": "Heaps",
        "type": "datastructure",
        "difficulty": "medium",
        "duration": "1 hours",
        "lessons": [
            {
                "title": "Introduction to Heaps",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A heap is a special tree-based data structure that satisfies the heap property: In a **min-heap**, for any given node, the value of the node is smaller than or equal to the values of its children. In a **max-heap**, the value of the node is greater than or equal to the values of its children. Heaps are often used to implement priority queues because they allow efficient retrieval of the minimum or maximum element."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "In a **min-heap**, the root is the smallest element.",
                            "In a **max-heap**, the root is the largest element.",
                            "Common operations: insert, delete, extract-min (or max)."
                        ]
                    }
                ]
            },
            {
                "title": "Heap Implementation in Python",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Python provides a built-in module `heapq` to implement heaps. By default, `heapq` implements a min-heap. A max-heap can be implemented by negating the values."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\n# Create an empty heap\nheap = []\n\n# Insert elements into the heap\nheapq.heappush(heap, 10)\nheapq.heappush(heap, 5)\nheapq.heappush(heap, 20)\n\n# Get the smallest element\nprint(heapq.heappop(heap))  # Output: 5"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we use `heapq.heappush()` to insert elements into the heap and `heapq.heappop()` to remove and return the smallest element."
                    }
                ]
            },
            {
                "title": "Inserting Elements into a Heap",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To insert an element into a heap, use `heapq.heappush()`. This operation maintains the heap property by comparing the newly inserted element with its parent and swapping if necessary."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\nheap = []\nheapq.heappush(heap, 30)\nheapq.heappush(heap, 10)\nheapq.heappush(heap, 20)\nprint(heap)  # Output: [10, 30, 20]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the smallest element, 10, becomes the root, maintaining the min-heap property."
                    }
                ]
            },
            {
                "title": "Extracting the Minimum or Maximum",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To extract the smallest element in a min-heap (or the largest in a max-heap), use `heapq.heappop()`. This operation removes and returns the root element while maintaining the heap property."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\nheap = [10, 20, 30]\nheapq.heapify(heap)  # Transform list into a heap\n\n# Extract the smallest element\nsmallest = heapq.heappop(heap)\nprint(smallest)  # Output: 10\nprint(heap)      # Output: [20, 30]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the smallest element, 10, is extracted, and the heap is adjusted to maintain its properties."
                    }
                ]
            },
            {
                "title": "Building a Heap from a List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To create a heap from an existing list, use the `heapq.heapify()` function. This transforms the list into a heap in O(n) time."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\nnums = [15, 20, 5, 10, 30]\nheapq.heapify(nums)\nprint(nums)  # Output: [5, 10, 15, 20, 30]"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, the list is rearranged to satisfy the heap property, with the smallest element at the root."
                    }
                ]
            },
            {
                "title": "Max-Heap Implementation",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To implement a max-heap using `heapq`, you can negate the values of the elements. The min-heap properties will then operate as a max-heap."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\nheap = []\nheapq.heappush(heap, -10)\nheapq.heappush(heap, -5)\nheapq.heappush(heap, -20)\n\n# Extract the largest element\nlargest = -heapq.heappop(heap)\nprint(largest)  # Output: 10"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, negating the values allows the `heapq` min-heap to function as a max-heap, with the largest element being extracted."
                    }
                ]
            },
            {
                "title": "Merging Sorted Heaps",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can merge multiple sorted heaps into one sorted sequence using `heapq.merge()`. This function returns an iterator over the sorted values."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\nheap1 = [1, 3, 5]\nheap2 = [2, 4, 6]\n\n# Merge the two heaps\nmerged = heapq.merge(heap1, heap2)\nprint(list(merged))  # Output: [1, 2, 3, 4, 5, 6]"
                    },
                    {
                        "type": "paragraph",
                        "text": "This function efficiently merges multiple sorted heaps into a single sorted sequence."
                    }
                ]
            },
            {
                "title": "Finding the k Smallest or Largest Elements",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To find the `k` smallest or largest elements in a list, you can use the `heapq.nsmallest()` or `heapq.nlargest()` functions, which efficiently return the desired elements from a heap."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\nnums = [15, 10, 30, 20, 5]\n\n# Find the 3 smallest elements\nsmallest_three = heapq.nsmallest(3, nums)\nprint(smallest_three)  # Output: [5, 10, 15]\n\n# Find the 3 largest elements\nlargest_three = heapq.nlargest(3, nums)\nprint(largest_three)  # Output: [30, 20, 15]"
                    },
                    {
                        "type": "paragraph",
                        "text": "These functions quickly return the `k` smallest or largest elements from a list, which is useful in scenarios like finding the top `k` performers."
                    }
                ]
            },
            {
                "title": "Heap Use Cases",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Heaps are commonly used in scenarios that involve maintaining a dynamically changing set of elements, such as:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Implementing priority queues, where elements are processed based on their priority.",
                            "Efficiently finding the `k` smallest or largest elements in a dataset.",
                            "Scheduling algorithms, where tasks with the highest priority are processed first.",
                            "Algorithms like Dijkstra\u2019s shortest path algorithm and Prim\u2019s minimum spanning tree algorithm."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we covered the basic concepts of heaps, including inserting and extracting elements, building a heap from a list, and common use cases. Heaps are a versatile data structure used in many algorithms where efficient retrieval of the minimum or maximum element is required."
                    }
                ]
            }
        ]
    },
    {
        "title": "Breadth-First Search",
        "type": "algorithm",
        "difficulty": "medium",
        "duration": "1.5 hours",
        "lessons": [
            {
                "title": "Introduction to Breadth-First Search",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "**Breadth-First Search (BFS)** is a graph traversal algorithm that explores all the nodes at the present depth level before moving on to nodes at the next depth level. It is used to explore nodes and edges in a graph and is particularly useful for finding the shortest path in an unweighted graph."
                    },
                    {
                        "type": "paragraph",
                        "text": "BFS starts from a source node and explores all its immediate neighbors, then moves on to the neighbors of those neighbors, and so on, until all nodes have been visited. BFS uses a **queue** to keep track of nodes to visit."
                    }
                ]
            },
            {
                "title": "Graph Representation (Adjacency List)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Graphs can be represented using an **adjacency list**. In this representation, each node points to a list of its neighbors. This is a common way to represent graphs for BFS."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Example of an adjacency list representation of a graph\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F'],\n    'D': [],\n    'E': ['F'],\n    'F': []\n}\n"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this adjacency list, each key is a node, and the value is a list of its adjacent nodes (neighbors). For example, node `'A'` is connected to nodes `'B'` and `'C'`."
                    }
                ]
            },
            {
                "title": "Iterative BFS Implementation (Using a Queue)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "BFS is typically implemented using a **queue**. The algorithm starts by adding the starting node to the queue, then iterates through the queue, visiting each node's neighbors and adding unvisited neighbors to the queue."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Iterative BFS implementation using a queue\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        node = queue.popleft()\n        print(node, end=' ')\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n# Test the BFS implementation\nprint('BFS Traversal:')\nbfs(graph, 'A')  # Output: A B C D E F"
                    },
                    {
                        "type": "paragraph",
                        "text": "In the `bfs()` function, we initialize a queue with the starting node and use a set to track visited nodes. We then iterate through the queue, exploring each node's neighbors, and printing the traversal order."
                    }
                ]
            },
            {
                "title": "BFS Complexity Analysis",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The time complexity of BFS is **O(V + E)**, where `V` is the number of vertices (nodes) and `E` is the number of edges in the graph. BFS visits every vertex and every edge exactly once."
                    },
                    {
                        "type": "paragraph",
                        "text": "The space complexity of BFS is **O(V)** due to the storage of the queue and the visited set, which can store up to `V` vertices at any given time."
                    }
                ]
            },
            {
                "title": "Applications of Breadth-First Search",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "BFS has several important applications in computer science and graph theory, including:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Finding the shortest path**: BFS guarantees finding the shortest path in an unweighted graph, as it explores nodes level by level.",
                            "**Graph traversal**: BFS is commonly used to traverse all reachable nodes from a given starting node.",
                            "**Level-order traversal**: BFS can be used to perform level-order traversal of trees, visiting nodes level by level."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we covered the basics of **Breadth-First Search (BFS)**, its iterative implementation using a queue, and its applications. BFS is a powerful and widely used graph traversal algorithm, especially when the goal is to explore nodes level by level or find the shortest path in an unweighted graph."
                    }
                ]
            }
        ]
    },
    {
        "title": "Depth-First Search",
        "type": "algorithm",
        "difficulty": "medium",
        "duration": "1.5 hours",
        "lessons": [
            {
                "title": "Introduction to Depth-First Search",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "**Depth-First Search (DFS)** is a graph traversal algorithm that explores as far as possible along a branch before backtracking. It is used to explore the nodes and edges of a graph in a depth-oriented manner. DFS can be applied to both directed and undirected graphs."
                    },
                    {
                        "type": "paragraph",
                        "text": "The primary goal of DFS is to fully explore one path before moving to another. This approach makes it useful in solving problems like detecting cycles, finding connected components, and exploring all nodes in a graph."
                    }
                ]
            },
            {
                "title": "Graph Representation (Adjacency List)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Graphs can be represented using an **adjacency list**, where each node stores a list of adjacent nodes (its neighbors). This is the most common way to represent graphs for DFS traversal."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Example of an adjacency list representation of a graph\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F'],\n    'D': [],\n    'E': ['F'],\n    'F': []\n}\n"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this adjacency list, each key represents a node, and its value is a list of neighboring nodes. For example, node `'A'` is connected to nodes `'B'` and `'C'`."
                    }
                ]
            },
            {
                "title": "Recursive DFS Implementation",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "DFS can be implemented recursively by exploring one branch of the graph deeply and then backtracking once a dead end is reached. The base case for the recursion is when all adjacent nodes of a current node have been visited."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Recursive DFS implementation\ndef dfs_recursive(graph, node, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(node)\n    print(node, end=' ')\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs_recursive(graph, neighbor, visited)\n\n# Test the recursive DFS\ndfs_recursive(graph, 'A')  # Output: A B D E F C"
                    },
                    {
                        "type": "paragraph",
                        "text": "The `dfs_recursive()` function starts from a given node, marks it as visited, and recursively explores all unvisited neighbors until all nodes connected to the starting node have been visited."
                    }
                ]
            },
            {
                "title": "Iterative DFS Implementation (Using a Stack)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "DFS can also be implemented iteratively using an explicit stack. This approach mimics the recursive behavior by pushing nodes onto a stack and popping them as they are explored."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Iterative DFS implementation\ndef dfs_iterative(graph, start):\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            print(node, end=' ')\n            visited.add(node)\n            # Add neighbors to the stack in reverse order\n            stack.extend(reversed(graph[node]))\n\n# Test the iterative DFS\ndfs_iterative(graph, 'A')  # Output: A B D E F C"
                    },
                    {
                        "type": "paragraph",
                        "text": "In the `dfs_iterative()` function, we simulate the recursive behavior by using a stack. We pop nodes off the stack, mark them as visited, and push their unvisited neighbors back onto the stack."
                    }
                ]
            },
            {
                "title": "DFS Complexity Analysis",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The time complexity of DFS is **O(V + E)**, where `V` is the number of vertices (nodes) and `E` is the number of edges in the graph. This is because DFS visits each vertex and each edge exactly once."
                    },
                    {
                        "type": "paragraph",
                        "text": "The space complexity of DFS depends on the depth of the recursion or the size of the stack. In the worst case, this can be **O(V)** if the graph is a long chain."
                    }
                ]
            },
            {
                "title": "Applications of Depth-First Search",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "DFS is widely used in a variety of applications, including:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Pathfinding**: DFS can be used to explore all possible paths in a graph.",
                            "**Cycle Detection**: Detecting cycles in a directed or undirected graph.",
                            "**Topological Sorting**: DFS is the basis for topological sorting in a Directed Acyclic Graph (DAG).",
                            "**Finding Connected Components**: DFS can be used to find all connected components in an undirected graph."
                        ]
                    }
                ]
            },
            {
                "title": "DFS Limitations",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "While DFS is a powerful graph traversal algorithm, it does not guarantee the shortest path in an unweighted graph. For shortest path problems, algorithms like **Breadth-First Search (BFS)** or **Dijkstra's Algorithm** are preferred."
                    },
                    {
                        "type": "paragraph",
                        "text": "DFS can also lead to deep recursion, which may cause a stack overflow if the graph is large and the recursion depth exceeds the system's limit."
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we learned about **Depth-First Search (DFS)**, its recursive and iterative implementations, and its applications. DFS is a versatile and foundational algorithm in graph theory, widely used in solving problems that involve exploring or traversing graphs."
                    }
                ]
            }
        ]
    },
    {
        "title": "Dynamic Programming",
        "type": "concept",
        "difficulty": "hard",
        "duration": "3 hours",
        "lessons": [
            {
                "title": "Introduction to Dynamic Programming",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Dynamic Programming (DP) is an optimization technique used to solve problems by breaking them down into simpler sub-problems and storing the solutions of these sub-problems to avoid redundant computations."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Dynamic programming is particularly useful for problems with overlapping sub-problems and optimal substructure.",
                            "By storing solutions to sub-problems, DP reduces the time complexity of certain problems from exponential to polynomial time."
                        ]
                    }
                ]
            },
            {
                "title": "Types of Dynamic Programming",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Top-down approach (Memoization): Solve the problem recursively and store the results of sub-problems to avoid redundant computations.",
                            "Bottom-up approach (Tabulation): Build up a table (array) of solutions from the simplest sub-problems to the complete problem."
                        ]
                    }
                ]
            },
            {
                "title": "Memoization (Top-Down)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Memoization is the top-down approach where we solve the problem recursively and store the results of sub-problems in a cache (or memo) to reuse later instead of recalculating."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def fib(n, memo={}):\n    if n <= 1:\n        return n\n    if n not in memo:\n        memo[n] = fib(n - 1, memo) + fib(n - 2, memo)\n    return memo[n]\n\nprint(fib(10))  # Output: 55"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this Fibonacci example, `fib(n)` recursively computes the Fibonacci number, but memoization ensures that previously computed results are reused, reducing time complexity to O(n)."
                    }
                ]
            },
            {
                "title": "Tabulation (Bottom-Up)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Tabulation is the bottom-up approach where we solve the problem by first solving the simplest sub-problems and storing the results in a table (array). We then use the results to solve more complex sub-problems."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def fib(n):\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\nprint(fib(10))  # Output: 55"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we use an array `dp` to store the Fibonacci numbers from `dp[0]` to `dp[n]`. The final result is stored in `dp[n]`, avoiding recursion and ensuring that each sub-problem is solved only once."
                    }
                ]
            },
            {
                "title": "Optimal Substructure",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A problem has an optimal substructure if the optimal solution to the problem can be obtained by combining optimal solutions to its sub-problems. Dynamic programming relies on this property to build solutions."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Example: The shortest path between two nodes in a graph can be obtained by combining the shortest paths between intermediate nodes."
                        ]
                    }
                ]
            },
            {
                "title": "Overlapping Sub-problems",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A problem has overlapping sub-problems if solving the problem involves solving the same sub-problems multiple times. Dynamic programming solves each sub-problem once and stores the result for future use."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def factorial(n, memo={}):\n    if n == 0 or n == 1:\n        return 1\n    if n not in memo:\n        memo[n] = n * factorial(n - 1, memo)\n    return memo[n]\n\nprint(factorial(5))  # Output: 120"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this factorial example, memoization ensures that each sub-problem (e.g., factorial of smaller numbers) is solved only once."
                    }
                ]
            },
            {
                "title": "Common Dynamic Programming Problems",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Fibonacci Sequence",
                            "0/1 Knapsack Problem",
                            "Longest Common Subsequence",
                            "Longest Increasing Subsequence",
                            "Coin Change Problem",
                            "Edit Distance",
                            "Rod Cutting Problem"
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "These problems benefit from dynamic programming because they involve overlapping sub-problems and can be broken down into smaller parts that build up to the final solution."
                    }
                ]
            },
            {
                "title": "Example: 0/1 Knapsack Problem",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In the 0/1 Knapsack problem, we aim to maximize the total value of items that fit into a knapsack with a given weight capacity. Each item can either be included or excluded (hence 0/1)."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def knapsack(weights, values, W):\n    n = len(weights)\n    dp = [[0] * (W + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(1, W + 1):\n            if weights[i - 1] <= w:\n                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])\n            else:\n                dp[i][w] = dp[i - 1][w]\n\n    return dp[n][W]\n\nweights = [2, 3, 4, 5]\nvalues = [3, 4, 5, 6]\nW = 5\nprint(knapsack(weights, values, W))  # Output: 7"
                    },
                    {
                        "type": "paragraph",
                        "text": "This DP solution builds a table where each entry `dp[i][w]` represents the maximum value that can be achieved using the first `i` items with a maximum capacity of `w`. The result is stored in `dp[n][W]`."
                    }
                ]
            },
            {
                "title": "Example: Longest Common Subsequence",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The Longest Common Subsequence (LCS) problem involves finding the longest sequence that can be derived from two given sequences while maintaining the relative order of elements."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def lcs(X, Y):\n    m = len(X)\n    n = len(Y)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i - 1] == Y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\nX = \"ABCBDAB\"\nY = \"BDCABC\"\nprint(lcs(X, Y))  # Output: 4"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we build a DP table where `dp[i][j]` stores the length of the LCS of `X[0:i]` and `Y[0:j]`. The final result is stored in `dp[m][n]`."
                    }
                ]
            },
            {
                "title": "When to Use Dynamic Programming",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Dynamic programming should be considered when a problem exhibits overlapping sub-problems and optimal substructure. It is most effective when recursive solutions result in redundant computations, and we can optimize by storing intermediate results."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Look for problems that can be broken down into smaller, repeated sub-problems.",
                            "If the recursive solution leads to exponential time complexity, DP is likely a good optimization."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Dynamic Programming is a powerful technique for solving optimization problems efficiently. By storing solutions to sub-problems, DP avoids redundant calculations and significantly improves time complexity for many common problems."
                    }
                ]
            }
        ]
    },
    {
        "title": "Graphs",
        "type": "datastructure",
        "difficulty": "hard",
        "duration": "3 hours",
        "lessons": [
            {
                "title": "Introduction to Graphs",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A **graph** is a data structure that consists of a set of **vertices** (also called nodes) and a set of **edges** that connect pairs of vertices. Graphs are used to represent various relationships between objects, and they are widely applied in areas such as computer networks, social networks, and transportation systems."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Vertices (nodes)**: The fundamental units of a graph, representing entities or objects.",
                            "**Edges**: The connections between vertices, representing relationships or interactions between them."
                        ]
                    }
                ]
            },
            {
                "title": "Types of Graphs",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "There are various types of graphs based on the nature of their vertices and edges:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Directed Graph**: A graph where edges have a direction, meaning each edge points from one vertex to another.",
                            "**Undirected Graph**: A graph where edges have no direction, meaning they simply connect two vertices.",
                            "**Weighted Graph**: A graph where each edge has a numerical value or weight, representing some cost or distance.",
                            "**Unweighted Graph**: A graph where edges have no associated weights.",
                            "**Cyclic Graph**: A graph that contains at least one cycle (a path that starts and ends at the same vertex).",
                            "**Acyclic Graph**: A graph with no cycles."
                        ]
                    }
                ]
            },
            {
                "title": "Graph Representation",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Graphs can be represented in several ways, with the most common being the **adjacency list** and the **adjacency matrix**."
                    }
                ]
            },
            {
                "title": "Adjacency List",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "An **adjacency list** represents a graph as a collection of lists. Each vertex points to a list of its adjacent vertices. This representation is memory efficient for sparse graphs."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Example of an adjacency list in Python\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D'],\n    'C': ['E'],\n    'D': ['F'],\n    'E': [],\n    'F': []\n}\n"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this adjacency list, vertex `'A'` has edges to vertices `'B'` and `'C'`. Similarly, vertex `'B'` is connected to vertex `'D'`, and so on."
                    }
                ]
            },
            {
                "title": "Adjacency Matrix",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "An **adjacency matrix** is a 2D array (or matrix) used to represent a graph. Each row and column represent a vertex, and the cell value at position `(i, j)` indicates whether there is an edge from vertex `i` to vertex `j`. In an unweighted graph, the cell value is `1` for an edge and `0` otherwise; in a weighted graph, the cell value contains the edge weight."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Example of an adjacency matrix for an unweighted graph\nadj_matrix = [\n    [0, 1, 1, 0, 0, 0],  # A -> B, C\n    [0, 0, 0, 1, 0, 0],  # B -> D\n    [0, 0, 0, 0, 1, 0],  # C -> E\n    [0, 0, 0, 0, 0, 1],  # D -> F\n    [0, 0, 0, 0, 0, 0],  # E has no edges\n    [0, 0, 0, 0, 0, 0]   # F has no edges\n]\n"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this adjacency matrix, the row index represents the starting vertex and the column index represents the ending vertex. For example, the entry at `(0, 1)` is `1`, meaning there is an edge from vertex `'A'` to vertex `'B'`."
                    }
                ]
            },
            {
                "title": "Graph Connectivity",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A graph is said to be **connected** if there is a path between every pair of vertices. In a **directed graph**, connectivity means that there is a directed path between every pair of vertices. In an **undirected graph**, connectivity simply means that vertices can be reached without considering edge directions."
                    },
                    {
                        "type": "paragraph",
                        "text": "If a graph is not connected, it can be broken down into **connected components**, which are subsets of the graph in which there is a path between any pair of vertices."
                    }
                ]
            },
            {
                "title": "Graph Density",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The **density** of a graph refers to the ratio of the number of edges in the graph to the total possible number of edges. A graph is considered **sparse** if it has relatively few edges compared to the number of vertices, and **dense** if it has many edges."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Calculating the density of a graph\nV = 6  # Number of vertices\nE = 5  # Number of edges in the graph\ndensity = 2 * E / (V * (V - 1))  # For an undirected graph\nprint('Graph Density:', density)"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, we calculate the density of an undirected graph with 6 vertices and 5 edges. The formula for density is `2 * E / (V * (V - 1))` for an undirected graph, and `E / (V * (V - 1))` for a directed graph."
                    }
                ]
            },
            {
                "title": "Weighted vs. Unweighted Graphs",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In a **weighted graph**, each edge has an associated numerical value or weight, which typically represents some cost, distance, or capacity. An **unweighted graph** does not have edge weights; instead, edges simply indicate a connection between vertices."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Example of a weighted graph using an adjacency list\ngraph_weighted = {\n    'A': [('B', 5), ('C', 3)],\n    'B': [('D', 2)],\n    'C': [('E', 7)],\n    'D': [('F', 1)],\n    'E': [],\n    'F': []\n}\n"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this weighted graph, the edges between vertices have weights. For example, there is an edge from vertex `'A'` to vertex `'B'` with a weight of `5`."
                    }
                ]
            },
            {
                "title": "Graph Use Cases",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Graphs are widely used in various fields and applications due to their flexibility in representing relationships between entities. Some common use cases include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Social Networks**: Representing users (vertices) and friendships or connections (edges).",
                            "**Computer Networks**: Representing devices as vertices and communication links as edges.",
                            "**Web Crawling**: Representing web pages as vertices and hyperlinks as edges.",
                            "**Transportation Systems**: Representing cities or locations as vertices and roads or routes as edges."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we covered the fundamentals of the **graph** data structure, including its types, representation, and key characteristics. Graphs are powerful tools for modeling complex relationships and are foundational in many fields of computer science."
                    }
                ]
            }
        ]
    },
    {
        "title": "Greedy",
        "type": "concept",
        "difficulty": "medium",
        "duration": "1.5 hours",
        "lessons": [
            {
                "title": "Introduction to Greedy Algorithms",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "A greedy algorithm is an approach for solving problems by making the best choice at each step in the hope that this will lead to an optimal solution. The greedy choice is based on a local criterion, but it doesn't always guarantee a global optimum."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Greedy algorithms make a series of choices, each of which looks the best at the moment.",
                            "It works well for problems where a local optimal choice leads to a global optimal solution.",
                            "Greedy algorithms are usually faster but do not always provide the correct or optimal solution for every problem."
                        ]
                    }
                ]
            },
            {
                "title": "Characteristics of Greedy Algorithms",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Greedy Choice Property: A global optimum can be arrived at by choosing the locally optimal choice at each step.",
                            "Optimal Substructure: A problem has an optimal substructure if the optimal solution to the problem can be constructed efficiently from the optimal solutions of its subproblems."
                        ]
                    }
                ]
            },
            {
                "title": "Common Examples of Greedy Algorithms",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Activity Selection Problem",
                            "Fractional Knapsack Problem",
                            "Huffman Encoding",
                            "Prim's Minimum Spanning Tree",
                            "Kruskal's Minimum Spanning Tree",
                            "Dijkstra's Shortest Path Algorithm"
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "These are problems where the greedy approach works well and guarantees an optimal solution."
                    }
                ]
            },
            {
                "title": "Activity Selection Problem",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The Activity Selection Problem is about selecting the maximum number of activities that don't overlap, given a set of activities with start and end times."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def activity_selection(activities):\n    activities.sort(key=lambda x: x[1])  # Sort by end time\n    selected = [activities[0]]\n\n    for i in range(1, len(activities)):\n        if activities[i][0] >= selected[-1][1]:  # Compare start time with the last selected activity's end time\n            selected.append(activities[i])\n\n    return selected\n\nactivities = [(1, 3), (2, 5), (4, 6), (6, 7), (5, 8)]\nprint(activity_selection(activities))  # Output: [(1, 3), (4, 6), (6, 7)]"
                    },
                    {
                        "type": "paragraph",
                        "text": "The algorithm sorts activities by their end times and then selects the first activity that doesn't overlap with the previously selected activity. This is a classic example where the greedy choice results in an optimal solution."
                    }
                ]
            },
            {
                "title": "Fractional Knapsack Problem",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In the Fractional Knapsack Problem, you can take fractions of items rather than whole items. The goal is to maximize the total value that fits into a knapsack with a given capacity."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def fractional_knapsack(values, weights, capacity):\n    index = list(range(len(values)))\n    ratio = [v / w for v, w in zip(values, weights)]\n    index.sort(key=lambda i: ratio[i], reverse=True)  # Sort by value-to-weight ratio\n\n    max_value = 0\n    for i in index:\n        if weights[i] <= capacity:\n            max_value += values[i]\n            capacity -= weights[i]\n        else:\n            max_value += values[i] * (capacity / weights[i])\n            break\n\n    return max_value\n\nvalues = [60, 100, 120]\nweights = [10, 20, 30]\ncapacity = 50\nprint(fractional_knapsack(values, weights, capacity))  # Output: 240.0"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this problem, we select items based on their value-to-weight ratio. The algorithm works by taking as much as possible of the item with the highest ratio and moves to the next item until the knapsack is full. Greedy works optimally here because we can take fractions of the items."
                    }
                ]
            },
            {
                "title": "Huffman Encoding",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Huffman Encoding is a greedy algorithm used for lossless data compression. It assigns shorter binary codes to more frequent characters and longer codes to less frequent characters to minimize the total length of the encoded message."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\nclass Node:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n\n    def __lt__(self, other):\n        return self.freq < other.freq\n\n# Build Huffman Tree\ndef build_huffman_tree(frequencies):\n    heap = [Node(char, freq) for char, freq in frequencies.items()]\n    heapq.heapify(heap)\n\n    while len(heap) > 1:\n        node1 = heapq.heappop(heap)\n        node2 = heapq.heappop(heap)\n        merged = Node(None, node1.freq + node2.freq)\n        merged.left = node1\n        merged.right = node2\n        heapq.heappush(heap, merged)\n\n    return heap[0]\n\nfrequencies = {'a': 5, 'b': 9, 'c': 12, 'd': 13, 'e': 16, 'f': 45}\nroot = build_huffman_tree(frequencies)\nprint(root.freq)  # Output: 100"
                    },
                    {
                        "type": "paragraph",
                        "text": "Huffman Encoding builds a tree by repeatedly merging the two nodes with the lowest frequencies. This greedy approach results in the most optimal encoding for data compression."
                    }
                ]
            },
            {
                "title": "Prim's Minimum Spanning Tree Algorithm",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Prim\u2019s algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) of a graph. It starts with a single vertex and grows the MST by selecting the smallest edge that connects a new vertex to the tree."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\ndef prim_mst(graph):\n    start_vertex = 0\n    visited = [False] * len(graph)\n    min_heap = [(0, start_vertex)]\n    total_cost = 0\n\n    while min_heap:\n        cost, vertex = heapq.heappop(min_heap)\n        if visited[vertex]:\n            continue\n        total_cost += cost\n        visited[vertex] = True\n\n        for neighbor, weight in graph[vertex]:\n            if not visited[neighbor]:\n                heapq.heappush(min_heap, (weight, neighbor))\n\n    return total_cost\n\ngraph = {\n    0: [(1, 2), (3, 6)],\n    1: [(0, 2), (2, 3), (3, 8), (4, 5)],\n    2: [(1, 3), (4, 7)],\n    3: [(0, 6), (1, 8)],\n    4: [(1, 5), (2, 7)]\n}\nprint(prim_mst(graph))  # Output: 16"
                    },
                    {
                        "type": "paragraph",
                        "text": "Prim's algorithm greedily selects the smallest edge to grow the MST. It uses a priority queue to efficiently find the smallest edge at each step, ensuring the solution is optimal."
                    }
                ]
            },
            {
                "title": "Dijkstra's Shortest Path Algorithm",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Dijkstra\u2019s algorithm is a greedy algorithm used to find the shortest path between a starting node and all other nodes in a weighted graph. It repeatedly selects the node with the smallest known distance, then updates the distances to its neighbors."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[start] = 0\n    min_heap = [(0, start)]\n\n    while min_heap:\n        current_distance, current_vertex = heapq.heappop(min_heap)\n\n        if current_distance > distances[current_vertex]:\n            continue\n\n        for neighbor, weight in graph[current_vertex]:\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(min_heap, (distance, neighbor))\n\n    return distances\n\ngraph = {\n    'A': [('B', 1), ('C', 4)],\n    'B': [('A', 1), ('C', 2), ('D', 5)],\n    'C': [('A', 4), ('B', 2), ('D', 1)],\n    'D': [('B', 5), ('C', 1)]\n}\nprint(dijkstra(graph, 'A'))  # Output: {'A': 0, 'B': 1, 'C': 3, 'D': 4}"
                    },
                    {
                        "type": "paragraph",
                        "text": "Dijkstra\u2019s algorithm uses a greedy strategy to find the shortest path by always selecting the unvisited node with the smallest known distance. The priority queue helps manage the selection efficiently."
                    }
                ]
            },
            {
                "title": "When Greedy Algorithms Work",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Greedy algorithms work well when the problem satisfies the Greedy Choice Property and has an Optimal Substructure. If these conditions are met, the greedy approach is efficient and optimal."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Greedy Choice Property: Making local optimal choices leads to a global optimal solution.",
                            "Optimal Substructure: A problem has an optimal substructure if an optimal solution to the problem can be constructed from optimal solutions of its subproblems."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Greedy algorithms offer a fast and simple way to solve problems, but they do not always provide the optimal solution. They are effective for problems with the greedy choice property and optimal substructure, but for other problems, a more exhaustive approach, like dynamic programming, may be required."
                    }
                ]
            }
        ]
    },
    {
        "title": "Intervals",
        "type": "datastructure",
        "difficulty": "medium",
        "duration": "1.5 hours",
        "lessons": [
            {
                "title": "Introduction to Intervals",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "An interval is a range of numbers, usually represented by a start and an end. Intervals are commonly used in problems involving ranges, such as merging intervals, checking for overlaps, or finding gaps. In Python, intervals are typically represented as tuples or lists."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Intervals are typically represented as (start, end) pairs.",
                            "Common operations include checking overlap, merging intervals, and finding intersections."
                        ]
                    }
                ]
            },
            {
                "title": "Representing Intervals in Python",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In Python, intervals can be represented using tuples or lists. Each interval is defined by two values: the start and the end of the range."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "interval1 = (1, 5)\ninterval2 = [6, 10]\n\n# Example intervals: (1, 5) and (6, 10)"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, `interval1` is a tuple representing the interval [1, 5], and `interval2` is a list representing the interval [6, 10]. Both formats are commonly used."
                    }
                ]
            },
            {
                "title": "Checking for Overlapping Intervals",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To check if two intervals overlap, compare the start and end values of both intervals. Two intervals overlap if the start of one interval is less than or equal to the end of the other, and vice versa."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def intervals_overlap(interval1, interval2):\n    return interval1[0] <= interval2[1] and interval2[0] <= interval1[1]\n\n# Example\ninterval1 = (1, 5)\ninterval2 = (4, 8)\nprint(intervals_overlap(interval1, interval2))  # Output: True"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this function, the intervals overlap if the start of one interval is less than or equal to the end of the other, meaning there is at least one common number between them."
                    }
                ]
            },
            {
                "title": "Merging Overlapping Intervals",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "When given a list of intervals, it's common to merge overlapping intervals into one larger interval. This can be done by sorting the intervals by their start value and then merging overlapping ones."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])  # Sort intervals by start time\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            last[1] = max(last[1], current[1])  # Merge intervals\n        else:\n            merged.append(current)\n    return merged\n\n# Example\nintervals = [[1, 3], [2, 6], [8, 10], [15, 18]]\nprint(merge_intervals(intervals))  # Output: [[1, 6], [8, 10], [15, 18]]"
                    },
                    {
                        "type": "paragraph",
                        "text": "This function first sorts the intervals by their start value, then merges overlapping intervals. If two intervals overlap, their end values are merged into the larger one."
                    }
                ]
            },
            {
                "title": "Finding the Intersection of Two Intervals",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "To find the intersection (common range) between two intervals, check if they overlap and then return the maximum start value and the minimum end value."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def interval_intersection(interval1, interval2):\n    if intervals_overlap(interval1, interval2):\n        return (max(interval1[0], interval2[0]), min(interval1[1], interval2[1]))\n    return None\n\n# Example\ninterval1 = (1, 5)\ninterval2 = (4, 8)\nprint(interval_intersection(interval1, interval2))  # Output: (4, 5)"
                    },
                    {
                        "type": "paragraph",
                        "text": "This function calculates the intersection by returning the maximum of the start values and the minimum of the end values if the intervals overlap. Otherwise, it returns `None`."
                    }
                ]
            },
            {
                "title": "Finding Gaps Between Intervals",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In some applications, you may need to find gaps between intervals, i.e., ranges that are not covered by any of the intervals in a list. This can be done by sorting the intervals and identifying gaps between the end of one interval and the start of the next."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "def find_gaps(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    gaps = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] > intervals[i-1][1]:\n            gaps.append((intervals[i-1][1], intervals[i][0]))\n    return gaps\n\n# Example\nintervals = [[1, 3], [5, 8], [10, 12]]\nprint(find_gaps(intervals))  # Output: [(3, 5), (8, 10)]"
                    },
                    {
                        "type": "paragraph",
                        "text": "This function sorts the intervals and then looks for gaps by comparing the end of one interval with the start of the next. Any gaps are returned as a list of intervals."
                    }
                ]
            },
            {
                "title": "Use Cases of Intervals",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Intervals are commonly used in various fields, including:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Scheduling problems, such as booking time slots or managing events.",
                            "Range queries, such as finding overlapping ranges or checking for free time slots.",
                            "Computational geometry, such as finding intersecting lines or shapes.",
                            "Memory allocation in operating systems, where intervals represent blocks of allocated memory."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we covered the basics of working with intervals in Python, including representing intervals, checking for overlap, merging intervals, and finding intersections or gaps. Intervals are an important concept in many algorithms and can be applied to a wide range of problems."
                    }
                ]
            }
        ]
    },
    {
        "title": "Kadanes Algorithm",
        "type": "algorithm",
        "difficulty": "easy",
        "duration": "0.5 hour",
        "lessons": [
            {
                "title": "Introduction to Kadane's Algorithm",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "**Kadane\u2019s Algorithm** is a dynamic programming algorithm used to find the **maximum sum subarray** in a given array of integers (both positive and negative). The goal is to find the contiguous subarray within a one-dimensional array that has the largest sum."
                    },
                    {
                        "type": "paragraph",
                        "text": "Kadane\u2019s Algorithm is efficient with a time complexity of **O(n)**, making it one of the most optimal solutions for the maximum subarray sum problem."
                    }
                ]
            },
            {
                "title": "Problem Statement",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Given an array of integers, both positive and negative, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "For example, given the array `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`, the subarray with the largest sum is `[4, -1, 2, 1]`, which has a sum of `6`."
                        ]
                    }
                ]
            },
            {
                "title": "Kadane\u2019s Algorithm Approach",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Kadane\u2019s Algorithm works by maintaining two variables as it iterates through the array: `current_sum`, which stores the sum of the current subarray, and `max_sum`, which stores the maximum sum encountered so far."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "At each index, update `current_sum` to be the maximum of the current element alone or the current element added to the previous `current_sum`.",
                            "Update `max_sum` to be the maximum of `max_sum` and `current_sum`."
                        ]
                    }
                ]
            },
            {
                "title": "Kadane\u2019s Algorithm Implementation",
                "content": [
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Kadane's Algorithm to find the maximum sum subarray\ndef kadane(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n# Example usage\narr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint('Maximum Sum Subarray:', kadane(arr))  # Output: 6"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this implementation, we start by initializing both `max_sum` and `current_sum` to the first element of the array. As we iterate through the array, `current_sum` is updated to be either the current element or the sum of the current element and the previous `current_sum`. The `max_sum` keeps track of the highest sum encountered."
                    }
                ]
            },
            {
                "title": "Kadane's Algorithm Example Walkthrough",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Let\u2019s step through an example array `[-2, 1, -3, 4, -1, 2, 1, -5, 4]` to see how Kadane\u2019s Algorithm works."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Step 1**: Start with `max_sum = -2` and `current_sum = -2`.",
                            "**Step 2**: At index 1, compare `arr[1] = 1` with `current_sum + arr[1] = -1`. The maximum is `1`, so `current_sum = 1` and update `max_sum = 1`.",
                            "**Step 3**: At index 2, compare `arr[2] = -3` with `current_sum + arr[2] = -2`. The maximum is `-2`, so `current_sum = -2` and `max_sum` remains `1`.",
                            "**Step 4**: At index 3, compare `arr[3] = 4` with `current_sum + arr[3] = 2`. The maximum is `4`, so `current_sum = 4` and update `max_sum = 4`.",
                            "**Step 5**: Continue similarly, and at index 6, the maximum sum subarray is `[4, -1, 2, 1]` with `max_sum = 6`."
                        ]
                    }
                ]
            },
            {
                "title": "Edge Cases",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Kadane\u2019s Algorithm handles edge cases gracefully, including arrays with all negative numbers and arrays with a single element."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**All negative numbers**: Kadane\u2019s Algorithm will return the largest negative number. For example, in `[-3, -2, -1]`, the result will be `-1`.",
                            "**Single element**: If the array has only one element, the result will be the element itself."
                        ]
                    }
                ]
            },
            {
                "title": "Time and Space Complexity",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "**Time Complexity**: The time complexity of Kadane\u2019s Algorithm is **O(n)**, where `n` is the number of elements in the array. This is because we only traverse the array once."
                    },
                    {
                        "type": "paragraph",
                        "text": "**Space Complexity**: The space complexity is **O(1)** since we are using only a constant amount of extra space (for `current_sum` and `max_sum`)."
                    }
                ]
            },
            {
                "title": "Applications of Kadane's Algorithm",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Kadane\u2019s Algorithm is widely used in problems where finding the maximum sum subarray is required. Some practical applications include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Stock Market Analysis**: Finding the maximum profit over a series of stock prices.",
                            "**Contiguous Subarrays**: Kadane's Algorithm can be extended to multidimensional arrays or applied to various subarray problems in dynamic programming.",
                            "**Temperature Data**: Analyzing temperature changes over a period to find the period with the greatest increase."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we covered **Kadane\u2019s Algorithm**, which provides an efficient way to find the maximum sum subarray in an array. With a time complexity of **O(n)**, it is optimal for solving this problem. Understanding Kadane\u2019s Algorithm is important for tackling a variety of problems in dynamic programming."
                    }
                ]
            }
        ]
    },
    {
        "title": "Topological Sort",
        "type": "algorithm",
        "difficulty": "hard",
        "duration": "1 hour",
        "lessons": [
            {
                "title": "Introduction to Topological Sort",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "**Topological Sort** is a linear ordering of vertices in a **Directed Acyclic Graph (DAG)**, such that for every directed edge `uv` from vertex `u` to vertex `v`, vertex `u` comes before vertex `v` in the ordering. Topological sorting is not possible if the graph contains cycles."
                    },
                    {
                        "type": "paragraph",
                        "text": "Topological Sort is primarily used in scenarios where certain tasks must be performed before others, such as scheduling tasks, course prerequisites, or resolving dependencies in build systems."
                    }
                ]
            },
            {
                "title": "Properties of Topological Sort",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Applicable only to **Directed Acyclic Graphs (DAGs)**.",
                            "A **directed edge** from `u` to `v` means `u` must come before `v` in the topological order.",
                            "If the graph contains a cycle, **topological sorting is not possible**."
                        ]
                    },
                    {
                        "type": "paragraph",
                        "text": "Multiple valid topological sorts can exist for the same graph, depending on the graph structure and traversal approach."
                    }
                ]
            },
            {
                "title": "Graph Representation (Adjacency List)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "For topological sorting, we often use an **adjacency list** to represent the graph. Each vertex points to a list of its neighboring vertices (i.e., the vertices that depend on it)."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Example of an adjacency list representation of a DAG\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D'],\n    'C': ['D'],\n    'D': ['E'],\n    'E': []\n}\n"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this example, vertex `'A'` must come before vertices `'B'` and `'C'`, and both `'B'` and `'C'` must come before `'D'`, with `'D'` coming before `'E'`."
                    }
                ]
            },
            {
                "title": "Topological Sort using Depth-First Search (DFS)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Topological sorting can be performed using **Depth-First Search (DFS)**. As we perform DFS, we recursively visit all adjacent nodes. Once a node's neighbors have been visited, the node itself is added to the stack. Finally, we reverse the stack to obtain the topological order."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Topological sort using DFS\ndef topological_sort_dfs(graph):\n    visited = set()\n    stack = []\n\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n        stack.append(node)\n\n    for node in graph:\n        if node not in visited:\n            dfs(node)\n\n    return stack[::-1]  # Return the reversed stack as the topological order\n\n# Test the topological sort\nprint('Topological Sort (DFS):', topological_sort_dfs(graph))\n# Output: ['A', 'C', 'B', 'D', 'E']"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this DFS-based approach, we recursively visit each node and its neighbors. Once all the neighbors are processed, we append the node to the stack. The stack is reversed at the end to obtain the correct topological ordering."
                    }
                ]
            },
            {
                "title": "Topological Sort using Kahn's Algorithm (BFS)",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Kahn's algorithm is an alternative approach to topological sorting using **Breadth-First Search (BFS)**. It processes nodes in the order of their **in-degree** (the number of incoming edges). Nodes with zero in-degree (no dependencies) are processed first, and then their neighbors' in-degrees are decremented. The process continues until all nodes are processed."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Topological sort using Kahn's Algorithm (BFS)\nfrom collections import deque, defaultdict\n\ndef topological_sort_kahn(graph):\n    in_degree = defaultdict(int)\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n\n    # Initialize the queue with nodes that have no incoming edges\n    queue = deque([node for node in graph if in_degree[node] == 0])\n    topo_order = []\n\n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(topo_order) == len(graph):\n        return topo_order\n    else:\n        return []  # Return empty list if there is a cycle\n\n# Test Kahn's Algorithm for topological sort\nprint('Topological Sort (Kahn):', topological_sort_kahn(graph))\n# Output: ['A', 'B', 'C', 'D', 'E']"
                    },
                    {
                        "type": "paragraph",
                        "text": "In Kahn's Algorithm, we first calculate the in-degree of each node and enqueue nodes with zero in-degree. We then repeatedly dequeue a node, add it to the topological order, and reduce the in-degree of its neighbors."
                    }
                ]
            },
            {
                "title": "Topological Sort Complexity",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The time complexity of topological sort (both DFS and Kahn's Algorithm) is **O(V + E)**, where `V` is the number of vertices and `E` is the number of edges in the graph. This is because we visit every vertex and edge exactly once."
                    },
                    {
                        "type": "paragraph",
                        "text": "The space complexity is **O(V)** because we need to store the in-degrees of the vertices (for Kahn's algorithm) and the recursion stack (for DFS)."
                    }
                ]
            },
            {
                "title": "Applications of Topological Sort",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Topological sorting is widely used in scenarios where there is a dependency relationship between tasks or entities. Some common applications include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Task Scheduling**: Scheduling tasks that have dependencies, where one task must be completed before another can begin.",
                            "**Course Prerequisites**: Determining the order in which courses must be taken based on prerequisites.",
                            "**Build Systems**: Resolving dependencies in software build systems, where certain files must be compiled before others."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we explored **topological sorting**, including two approaches: **DFS-based** and **Kahn's Algorithm** (BFS-based). Topological sort is a key technique in tasks where ordering based on dependencies is required, and it can only be applied to **Directed Acyclic Graphs (DAGs)**."
                    }
                ]
            }
        ]
    },
    {
        "title": "Union-Find",
        "type": "algorithm",
        "difficulty": "hard",
        "duration": "1.5 hours",
        "lessons": [
            {
                "title": "Introduction to Union-Find",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The **Union-Find** data structure, also known as **Disjoint Set Union (DSU)**, is a data structure that tracks a set of elements partitioned into disjoint (non-overlapping) subsets. It supports two main operations: **union** (merging two subsets into one) and **find** (determining which subset a particular element belongs to)."
                    },
                    {
                        "type": "paragraph",
                        "text": "Union-Find is widely used in graph-related algorithms such as **Kruskal's Algorithm** for finding Minimum Spanning Trees, and in problems where you need to determine whether two elements are in the same subset or connected component."
                    }
                ]
            },
            {
                "title": "Key Operations in Union-Find",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "**Find**: This operation determines which subset (or component) a particular element belongs to. It helps to determine if two elements are in the same subset.",
                            "**Union**: This operation merges two subsets into a single subset.",
                            "**Connected**: This checks if two elements are in the same subset by comparing their roots (leaders)."
                        ]
                    }
                ]
            },
            {
                "title": "Union-Find Data Structure",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The Union-Find data structure can be implemented using two key ideas: **path compression** and **union by rank**. These optimizations help improve the efficiency of the `find` and `union` operations."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Path Compression**: When performing a `find` operation, make the tree flatter by making each node point directly to the root. This reduces the depth of the tree and speeds up future operations.",
                            "**Union by Rank**: When performing a `union` operation, attach the smaller tree under the root of the larger tree. This helps keep the tree balanced, minimizing its height."
                        ]
                    }
                ]
            },
            {
                "title": "Union-Find Implementation",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Here is a Python implementation of Union-Find with path compression and union by rank:"
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Union-Find (Disjoint Set Union) with Path Compression and Union by Rank\nclass UnionFind:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]  # Initialize each node to be its own parent\n        self.rank = [1] * size  # Initialize rank (tree height) for each node\n\n    def find(self, x):\n        if self.root[x] == x:  # If x is its own root\n            return x\n        # Path compression: make the root of x the root of its parent\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            # Union by rank: attach smaller tree under the larger tree's root\n            if self.rank[rootX] > self.rank[rootY]:\n                self.root[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.root[rootX] = rootY\n            else:\n                self.root[rootY] = rootX\n                self.rank[rootX] += 1\n\n    def connected(self, x, y):\n        # Check if two nodes are in the same component\n        return self.find(x) == self.find(y)\n\n# Example usage\nuf = UnionFind(10)  # Create 10 disjoint sets (0 to 9)\nuf.union(1, 2)\nuf.union(2, 5)\nuf.union(5, 6)\nuf.union(6, 7)\nuf.union(3, 8)\nuf.union(8, 9)\nprint(uf.connected(1, 5))  # Output: True\nprint(uf.connected(1, 3))  # Output: False\nuf.union(5, 3)\nprint(uf.connected(1, 3))  # Output: True"
                    },
                    {
                        "type": "paragraph",
                        "text": "In this implementation, each node starts as its own root. The `find()` function uses path compression to reduce the tree's height, and `union()` uses union by rank to keep the tree balanced."
                    }
                ]
            },
            {
                "title": "Path Compression",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In the Union-Find structure, **path compression** is an optimization that speeds up the `find()` operation. When finding the root of a node, path compression makes all nodes in the path point directly to the root, effectively flattening the tree. This reduces the depth of the tree and speeds up future `find()` operations."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Path compression in the find() operation\n    def find(self, x):\n        if self.root[x] != x:\n            self.root[x] = self.find(self.root[x])  # Path compression\n        return self.root[x]"
                    },
                    {
                        "type": "paragraph",
                        "text": "The above implementation ensures that during the `find()` operation, all nodes encountered on the path to the root will point directly to the root."
                    }
                ]
            },
            {
                "title": "Union by Rank",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "**Union by Rank** is an optimization technique that keeps the Union-Find trees balanced by attaching the tree with lower rank (height) to the root of the tree with a higher rank. This prevents the tree from growing too tall, making both `union()` and `find()` operations more efficient."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Union by rank in the union() operation\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.root[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.root[rootX] = rootY\n            else:\n                self.root[rootY] = rootX\n                self.rank[rootX] += 1"
                    },
                    {
                        "type": "paragraph",
                        "text": "With union by rank, we compare the rank (height) of two trees, and the smaller tree is attached under the root of the larger tree. If both trees have the same rank, we arbitrarily choose one as the root and increment its rank."
                    }
                ]
            },
            {
                "title": "Complexity of Union-Find",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "With the optimizations of path compression and union by rank, the time complexity of the **find** and **union** operations becomes almost constant, or **O(\u03b1(n))**, where **\u03b1** is the inverse Ackermann function. For all practical purposes, this is very close to **O(1)**."
                    },
                    {
                        "type": "paragraph",
                        "text": "Without these optimizations, the worst-case time complexity for **find** and **union** would be **O(n)**, as the trees could become unbalanced and tall."
                    }
                ]
            },
            {
                "title": "Applications of Union-Find",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "The Union-Find data structure is widely used in many graph-related algorithms and real-world applications. Some common use cases include:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "**Cycle Detection**: Union-Find can be used to detect cycles in an undirected graph by checking if two vertices belong to the same subset.",
                            "**Kruskal's Algorithm**: For finding the Minimum Spanning Tree of a graph, Union-Find helps in efficiently checking if adding an edge creates a cycle.",
                            "**Connected Components**: Union-Find helps in determining connected components in a graph by grouping vertices into subsets.",
                            "**Network Connectivity**: In network connectivity problems, Union-Find helps to determine if two nodes (e.g., computers) are in the same network."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "In this tutorial, we explored the **Union-Find** data structure, also known as **Disjoint Set Union (DSU)**. We learned about the core operations of `find()` and `union()`, and the optimizations of path compression and union by rank. Union-Find is a powerful tool for solving problems related to connected components, cycle detection, and graph partitioning, making it an essential data structure in computer science."
                    }
                ]
            }
        ]
    },
    {
        "title": "Bit Manipulation",
        "type": "concept",
        "difficulty": "easy",
        "duration": "1 hour",
        "lessons": [
            {
                "title": "Introduction to Bit Manipulation",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Bit manipulation is the act of algorithmically manipulating bits or binary digits, which is the most basic form of data in computing. Understanding bit manipulation allows for more efficient algorithms, especially for problems involving numbers."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "Bit manipulation involves operations like AND, OR, XOR, NOT, shifts, and masks.",
                            "It is used to optimize space and time complexities, especially in low-level programming.",
                            "Common applications include solving problems related to sets, parity, and binary representations."
                        ]
                    }
                ]
            },
            {
                "title": "Common Bitwise Operators",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Here are the common bitwise operators in Python:"
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "`&` (AND): Sets each bit to 1 if both bits are 1.",
                            "`|` (OR): Sets each bit to 1 if at least one of the bits is 1.",
                            "`^` (XOR): Sets each bit to 1 if only one of the bits is 1.",
                            "`~` (NOT): Inverts all the bits (flips 1 to 0 and vice versa).",
                            "`<<` (Left Shift): Shifts the bits of the number to the left by a specified number of positions.",
                            "`>>` (Right Shift): Shifts the bits of the number to the right by a specified number of positions."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "a = 5  # Binary: 101\nb = 3  # Binary: 011\nprint(a & b)  # Output: 1 (Binary: 001)\nprint(a | b)  # Output: 7 (Binary: 111)\nprint(a ^ b)  # Output: 6 (Binary: 110)\nprint(~a)     # Output: -6 (Binary: -110)"
                    }
                ]
            },
            {
                "title": "Using Shifts for Multiplication and Division",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Bitwise shifts are a powerful way to perform multiplication and division by powers of two efficiently."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "x = 4  # Binary: 100\nprint(x << 1)  # Multiply by 2: Output: 8 (Binary: 1000)\nprint(x >> 1)  # Divide by 2: Output: 2 (Binary: 10)"
                    },
                    {
                        "type": "paragraph",
                        "text": "Left shifting a number by `n` bits is equivalent to multiplying by 2^n, and right shifting is equivalent to dividing by 2^n."
                    }
                ]
            },
            {
                "title": "Setting and Clearing Bits",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can set or clear specific bits using bitwise operators."
                    },
                    {
                        "type": "bullets",
                        "items": [
                            "To set a bit at position `i` to 1: Use `x | (1 << i)`.",
                            "To clear a bit at position `i` to 0: Use `x & ~(1 << i)`."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "x = 8  # Binary: 1000\n# Set the 0th bit\nx = x | (1 << 0)\nprint(x)  # Output: 9 (Binary: 1001)\n\n# Clear the 3rd bit\nx = x & ~(1 << 3)\nprint(x)  # Output: 1 (Binary: 0001)"
                    }
                ]
            },
            {
                "title": "Toggling Bits",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can toggle a bit (flip it from 0 to 1 or 1 to 0) using the XOR operator."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "x = 5  # Binary: 101\n# Toggle the 1st bit\nx = x ^ (1 << 1)\nprint(x)  # Output: 7 (Binary: 111)"
                    },
                    {
                        "type": "paragraph",
                        "text": "XORing a bit with 1 flips the bit. If the bit is 0, it becomes 1, and if it is 1, it becomes 0."
                    }
                ]
            },
            {
                "title": "Checking the Value of a Bit",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "You can check if a specific bit is set or not using the AND operator."
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "x = 6  # Binary: 110\n# Check if the 1st bit is set\nif x & (1 << 1):\n    print('The 1st bit is set')  # Output: The 1st bit is set"
                    },
                    {
                        "type": "paragraph",
                        "text": "Using `x & (1 << i)` checks if the ith bit is set to 1 or not."
                    }
                ]
            },
            {
                "title": "Applications of Bit Manipulation",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "Checking if a number is a power of two: A number is a power of two if `n & (n - 1) == 0`.",
                            "Counting the number of set bits (Hamming Weight): Use bitwise AND to repeatedly clear the least significant set bit.",
                            "Swapping two numbers without using a temporary variable: Use XOR swapping.",
                            "Generating all subsets of a set: Use bitwise operations to generate all possible subsets."
                        ]
                    },
                    {
                        "type": "code",
                        "language": "python",
                        "code": "# Check if a number is a power of two\nn = 16\nif n & (n - 1) == 0:\n    print(f'{n} is a power of two')\n\n# Count the number of set bits\nn = 13  # Binary: 1101\ncount = 0\nwhile n:\n    count += 1\n    n = n & (n - 1)\nprint(f'Number of set bits: {count}')"
                    }
                ]
            },
            {
                "title": "Bit Manipulation Tips and Tricks",
                "content": [
                    {
                        "type": "bullets",
                        "items": [
                            "XOR of a number with itself is 0.",
                            "XOR of a number with 0 is the number itself.",
                            "Left shifts multiply a number by powers of two, while right shifts divide by powers of two.",
                            "The AND operator can be used to clear bits, and the OR operator can be used to set bits."
                        ]
                    }
                ]
            },
            {
                "title": "Conclusion",
                "content": [
                    {
                        "type": "paragraph",
                        "text": "Bit manipulation is a powerful tool that can optimize many problems, especially those dealing with binary numbers, memory, and performance constraints. Learning these techniques will help improve your problem-solving efficiency."
                    }
                ]
            }
        ]
    }
]