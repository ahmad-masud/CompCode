{
    "title": "Singly Linked Lists",
    "lessons": [
      {
        "title": "Introduction to Singly Linked Lists",
        "content": [
          {
            "type": "paragraph",
            "text": "A singly linked list is a linear data structure where each element is a separate object called a node. Each node contains two parts: the data and a reference (or link) to the next node in the sequence. The last node's reference points to `None`, indicating the end of the list."
          },
          {
            "type": "bullets",
            "items": [
              "Each node stores data and a pointer to the next node.",
              "The list terminates at a node whose pointer is `None`.",
              "A singly linked list allows efficient insertion and deletion operations."
            ]
          }
        ]
      },
      {
        "title": "Node Structure",
        "content": [
          {
            "type": "paragraph",
            "text": "In a singly linked list, each node consists of two parts: the data and a pointer to the next node. Below is an example of how to define a node in Python."
          },
          {
            "type": "code",
            "language": "python",
            "code": "class Node:\n    def __init__(self, data):\n        self.data = data  # Holds the data\n        self.next = None  # Points to the next node"
          },
          {
            "type": "paragraph",
            "text": "In this example, `data` stores the value of the node, and `next` is a pointer to the next node in the linked list."
          }
        ]
      },
      {
        "title": "Creating a Singly Linked List",
        "content": [
          {
            "type": "paragraph",
            "text": "A singly linked list can be represented as a collection of nodes, where each node points to the next node in the sequence. The `LinkedList` class maintains the head of the list, which points to the first node."
          },
          {
            "type": "code",
            "language": "python",
            "code": "class LinkedList:\n    def __init__(self):\n        self.head = None  # Head of the list\n\n    def is_empty(self):\n        return self.head is None"
          },
          {
            "type": "paragraph",
            "text": "In this class, `self.head` keeps track of the first node in the linked list. Initially, the linked list is empty, and `head` points to `None`."
          }
        ]
      },
      {
        "title": "Inserting a Node at the Beginning",
        "content": [
          {
            "type": "paragraph",
            "text": "To insert a node at the beginning of a singly linked list, you need to create a new node and update its next pointer to the current head of the list. The new node becomes the new head of the list."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def insert_at_beginning(self, data):\n    new_node = Node(data)\n    new_node.next = self.head  # Link new node to the former head\n    self.head = new_node  # Update head to the new node"
          },
          {
            "type": "paragraph",
            "text": "This method creates a new node and points its `next` to the current head of the list, effectively inserting it at the front."
          }
        ]
      },
      {
        "title": "Inserting a Node at the End",
        "content": [
          {
            "type": "paragraph",
            "text": "To insert a node at the end of a singly linked list, you need to traverse the list to find the last node and update its next pointer to the new node."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def insert_at_end(self, data):\n    new_node = Node(data)\n    if self.head is None:\n        self.head = new_node  # List was empty, new node is now head\n        return\n    last = self.head\n    while last.next:\n        last = last.next\n    last.next = new_node  # Link the last node to the new node"
          },
          {
            "type": "paragraph",
            "text": "This method traverses the list to find the last node and inserts the new node after it. If the list is empty, the new node becomes the head."
          }
        ]
      },
      {
        "title": "Deleting a Node by Value",
        "content": [
          {
            "type": "paragraph",
            "text": "To delete a node, you need to search for the node containing the specified value and update the `next` pointer of the previous node to skip the node to be deleted."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def delete_node(self, key):\n    temp = self.head\n\n    # If the head node itself holds the key to be deleted\n    if temp is not None:\n        if temp.data == key:\n            self.head = temp.next  # Move head to next node\n            temp = None\n            return\n\n    # Search for the key to be deleted\n    prev = None\n    while temp is not None:\n        if temp.data == key:\n            break\n        prev = temp\n        temp = temp.next\n\n    # If the key was not found\n    if temp is None:\n        return\n\n    # Unlink the node\n    prev.next = temp.next\n    temp = None"
          },
          {
            "type": "paragraph",
            "text": "This method first checks if the head contains the value to be deleted. If not, it searches the list for the node and updates the `next` pointer of the previous node to remove the target node."
          }
        ]
      },
      {
        "title": "Searching for a Node",
        "content": [
          {
            "type": "paragraph",
            "text": "To search for a node in the linked list, you need to traverse the list and compare each node's data to the target value."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def search(self, key):\n    current = self.head\n    while current:\n        if current.data == key:\n            return True\n        current = current.next\n    return False"
          },
          {
            "type": "paragraph",
            "text": "This method iterates through the list and returns `True` if a node with the target value is found, or `False` otherwise."
          }
        ]
      },
      {
        "title": "Displaying the Linked List",
        "content": [
          {
            "type": "paragraph",
            "text": "You can traverse the linked list to print out the data in each node."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def display(self):\n    current = self.head\n    while current:\n        print(current.data, end=' -> ')\n        current = current.next\n    print('None')"
          },
          {
            "type": "paragraph",
            "text": "This method traverses the list and prints each node's data, followed by an arrow pointing to the next node, ending with `None`."
          }
        ]
      },
      {
        "title": "Reversing a Singly Linked List",
        "content": [
          {
            "type": "paragraph",
            "text": "To reverse a singly linked list, you need to iterate through the list and adjust the pointers of each node to point to the previous node."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def reverse(self):\n    prev = None\n    current = self.head\n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    self.head = prev"
          },
          {
            "type": "paragraph",
            "text": "This method iteratively reverses the `next` pointers of all nodes so that the list is reversed in place."
          }
        ]
      },
      {
        "title": "Linked List Use Cases",
        "content": [
          {
            "type": "paragraph",
            "text": "Singly linked lists are useful in many scenarios, such as:"
          },
          {
            "type": "bullets",
            "items": [
              "Implementing stacks and queues",
              "Dynamic memory allocation",
              "Handling undo operations in software",
              "Tracking order of elements in a sequence"
            ]
          }
        ]
      },
      {
        "title": "Conclusion",
        "content": [
          {
            "type": "paragraph",
            "text": "In this tutorial, we covered the basic structure of singly linked lists, how to perform common operations like insertion, deletion, and searching, and how to traverse and reverse a linked list. Singly linked lists offer an efficient way to manage collections where dynamic memory allocation and fast insertions and deletions are required."
          }
        ]
      }
    ]
  }  