{
    "title": "Binary Search Trees (BST)",
    "lessons": [
      {
        "title": "Introduction to Binary Search Trees",
        "content": [
          {
            "type": "paragraph",
            "text": "A Binary Search Tree (BST) is a binary tree where each node has a comparable key (and an associated value) and satisfies the following properties: the key in each node is greater than the keys in all nodes of its left subtree, and less than the keys in all nodes of its right subtree. This allows for efficient searching, insertion, and deletion operations."
          },
          {
            "type": "bullets",
            "items": [
              "The left subtree contains nodes with keys less than the node’s key.",
              "The right subtree contains nodes with keys greater than the node’s key.",
              "Both subtrees must also be binary search trees."
            ]
          }
        ]
      },
      {
        "title": "Node Structure in a Binary Search Tree",
        "content": [
          {
            "type": "paragraph",
            "text": "In a binary search tree, each node contains data, a reference to the left child, and a reference to the right child."
          },
          {
            "type": "code",
            "language": "python",
            "code": "class Node:\n    def __init__(self, data):\n        self.data = data  # Holds the key/data\n        self.left = None  # Points to the left child\n        self.right = None  # Points to the right child"
          },
          {
            "type": "paragraph",
            "text": "Each node contains the data (key) and two pointers: `left` and `right`, which point to the left and right child nodes, respectively."
          }
        ]
      },
      {
        "title": "Inserting a Node in a BST",
        "content": [
          {
            "type": "paragraph",
            "text": "To insert a node in a BST, you start from the root and recursively find the correct position based on the node's value. If the new value is less than the current node, move to the left child; if greater, move to the right child."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def insert(self, root, key):\n    if root is None:\n        return Node(key)\n    if key < root.data:\n        root.left = self.insert(root.left, key)\n    else:\n        root.right = self.insert(root.right, key)\n    return root"
          },
          {
            "type": "paragraph",
            "text": "This method recursively finds the appropriate position for the new node and inserts it, ensuring the tree remains a valid binary search tree."
          }
        ]
      },
      {
        "title": "Searching for a Node in a BST",
        "content": [
          {
            "type": "paragraph",
            "text": "To search for a node in a BST, start at the root and recursively compare the target value to the current node’s value. If the value is less, move to the left subtree; if greater, move to the right subtree."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def search(self, root, key):\n    if root is None or root.data == key:\n        return root\n    if key < root.data:\n        return self.search(root.left, key)\n    return self.search(root.right, key)"
          },
          {
            "type": "paragraph",
            "text": "This method recursively searches for the key in the tree. It returns the node if found, or `None` if the key does not exist in the tree."
          }
        ]
      },
      {
        "title": "Deleting a Node in a BST",
        "content": [
          {
            "type": "paragraph",
            "text": "Deleting a node in a BST is more complex and involves three cases: (1) the node to be deleted has no children, (2) the node has one child, or (3) the node has two children. In the case of two children, you replace the node with its in-order successor (the smallest node in its right subtree)."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def delete(self, root, key):\n    if root is None:\n        return root\n    if key < root.data:\n        root.left = self.delete(root.left, key)\n    elif key > root.data:\n        root.right = self.delete(root.right, key)\n    else:\n        if root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        temp = self.find_min(root.right)\n        root.data = temp.data\n        root.right = self.delete(root.right, temp.data)\n    return root\n\n# Helper function to find the minimum value node\n def find_min(self, node):\n    current = node\n    while current.left is not None:\n        current = current.left\n    return current"
          },
          {
            "type": "paragraph",
            "text": "This method handles the deletion cases. If the node to be deleted has two children, it replaces the node with its in-order successor (the smallest node in the right subtree)."
          }
        ]
      },
      {
        "title": "In-order Traversal of a BST",
        "content": [
          {
            "type": "paragraph",
            "text": "In-order traversal of a binary search tree visits nodes in increasing order. The traversal starts from the leftmost node and proceeds to the rightmost node."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def inorder_traversal(self, root):\n    if root:\n        self.inorder_traversal(root.left)\n        print(root.data, end=' ')\n        self.inorder_traversal(root.right)"
          },
          {
            "type": "paragraph",
            "text": "This recursive method prints the nodes of the tree in ascending order. In a BST, in-order traversal is commonly used for sorting or retrieving ordered data."
          }
        ]
      },
      {
        "title": "Finding the Minimum and Maximum in a BST",
        "content": [
          {
            "type": "paragraph",
            "text": "In a binary search tree, the minimum value is the leftmost node, and the maximum value is the rightmost node."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def find_min(self, node):\n    current = node\n    while current.left is not None:\n        current = current.left\n    return current\n\n def find_max(self, node):\n    current = node\n    while current.right is not None:\n        current = current.right\n    return current"
          },
          {
            "type": "paragraph",
            "text": "These methods find the leftmost node (minimum) and the rightmost node (maximum) in the BST."
          }
        ]
      },
      {
        "title": "Balancing a BST",
        "content": [
          {
            "type": "paragraph",
            "text": "A binary search tree can become unbalanced if nodes are inserted in a sorted order, degrading its performance to O(n) for operations like search, insertion, and deletion. Balanced trees such as AVL or Red-Black Trees maintain logarithmic height, ensuring efficient operations. Balancing a BST typically involves rotations after insertions and deletions."
          },
          {
            "type": "paragraph",
            "text": "In a simple BST, no automatic balancing occurs. However, AVL Trees and Red-Black Trees enforce balancing rules to keep the tree's height logarithmic. Python's built-in `set()` or `dict()` data structures (which are typically implemented using balanced tree structures like Red-Black Trees) may be used if balance is required."
          }
        ]
      },
      {
        "title": "Binary Search Tree Use Cases",
        "content": [
          {
            "type": "paragraph",
            "text": "Binary search trees are widely used in several applications, such as:"
          },
          {
            "type": "bullets",
            "items": [
              "Efficient searching and sorting (O(log n) operations in balanced BSTs).",
              "Implementing associative arrays and priority queues.",
              "Database indexing, where data needs to be kept sorted.",
              "Constructing and storing dynamic sets and lookups."
            ]
          }
        ]
      },
      {
        "title": "Conclusion",
        "content": [
          {
            "type": "paragraph",
            "text": "In this tutorial, we covered the structure and operations of binary search trees, including node insertion, deletion, searching, traversal, and balancing. BSTs provide an efficient way to store and retrieve ordered data, making them a fundamental tool in many algorithms and applications."
          }
        ]
      }
    ]
  }  