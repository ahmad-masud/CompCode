{
    "title": "Queues",
    "lessons": [
      {
        "title": "Introduction to Queues",
        "content": [
          {
            "type": "paragraph",
            "text": "A queue is a collection of elements that follows the First-In-First-Out (FIFO) principle, where the first element added is the first one to be removed. Queues are commonly used in situations where you need to manage processes or tasks in the order they were added."
          },
          {
            "type": "bullets",
            "items": [
              "Enqueue: Add an element to the back of the queue.",
              "Dequeue: Remove an element from the front of the queue.",
              "FIFO (First-In, First-Out) structure."
            ]
          }
        ]
      },
      {
        "title": "Queue Implementation in Python",
        "content": [
          {
            "type": "paragraph",
            "text": "Python does not have a built-in queue data structure, but you can implement a queue using lists or by using the `queue` module for more robust functionality."
          },
          {
            "type": "bullets",
            "items": [
              "Using lists (simple but not efficient)",
              "Using `collections.deque` (recommended for efficient queues)",
              "Using the `queue` module (especially for multi-threading)"
            ]
          }
        ]
      },
      {
        "title": "Method 1: Implementing Queue Using Lists",
        "content": [
          {
            "type": "paragraph",
            "text": "The simplest way to implement a queue in Python is by using a list. You can append elements to the end of the list (enqueue) and remove elements from the front of the list (dequeue)."
          },
          {
            "type": "code",
            "language": "python",
            "code": "queue = []\nqueue.append('A')  # Enqueue 'A'\nqueue.append('B')  # Enqueue 'B'\nprint(queue.pop(0))  # Dequeue, Output: 'A'\nprint(queue)  # Output: ['B']"
          },
          {
            "type": "paragraph",
            "text": "While this works, using lists for queue operations is inefficient because removing elements from the front of the list takes O(n) time due to the need to shift all other elements."
          }
        ]
      },
      {
        "title": "Method 2: Implementing Queue Using collections.deque",
        "content": [
          {
            "type": "paragraph",
            "text": "A better way to implement a queue in Python is by using `collections.deque`. It allows O(1) time complexity for both enqueue and dequeue operations."
          },
          {
            "type": "code",
            "language": "python",
            "code": "from collections import deque\nqueue = deque()\nqueue.append('A')  # Enqueue 'A'\nqueue.append('B')  # Enqueue 'B'\nprint(queue.popleft())  # Dequeue, Output: 'A'\nprint(queue)  # Output: deque(['B'])"
          },
          {
            "type": "paragraph",
            "text": "`deque` is more efficient than lists for queue operations as it supports fast appends and pops from both ends."
          }
        ]
      },
      {
        "title": "Method 3: Implementing Queue Using queue.Queue",
        "content": [
          {
            "type": "paragraph",
            "text": "The `queue.Queue` class in Python is a thread-safe queue, often used in multi-threaded applications where multiple threads need to interact with the queue. It supports the following methods: `put()` (enqueue) and `get()` (dequeue)."
          },
          {
            "type": "code",
            "language": "python",
            "code": "import queue\nq = queue.Queue()\nq.put('A')  # Enqueue 'A'\nq.put('B')  # Enqueue 'B'\nprint(q.get())  # Dequeue, Output: 'A'\nprint(q.get())  # Dequeue, Output: 'B'"
          },
          {
            "type": "paragraph",
            "text": "The `queue.Queue` class also provides additional methods like `qsize()` to get the size of the queue, `empty()` to check if the queue is empty, and `full()` to check if the queue is full."
          }
        ]
      },
      {
        "title": "Priority Queues",
        "content": [
          {
            "type": "paragraph",
            "text": "A Priority Queue is a type of queue where each element has a priority assigned to it. Elements with higher priority are dequeued before elements with lower priority. Python provides the `queue.PriorityQueue` class for implementing this structure."
          },
          {
            "type": "code",
            "language": "python",
            "code": "import queue\npq = queue.PriorityQueue()\npq.put((1, 'low priority'))\npq.put((0, 'high priority'))\nprint(pq.get())  # Output: (0, 'high priority')\nprint(pq.get())  # Output: (1, 'low priority')"
          },
          {
            "type": "paragraph",
            "text": "In this implementation, elements are stored as tuples with the first value representing the priority, where lower numbers represent higher priority."
          }
        ]
      },
      {
        "title": "Common Queue Methods",
        "content": [
          {
            "type": "paragraph",
            "text": "Queues have several common methods that help manage and interact with the elements:"
          },
          {
            "type": "bullets",
            "items": [
              "`put(item)`: Adds an element to the end of the queue.",
              "`get()`: Removes and returns an element from the front of the queue.",
              "`qsize()`: Returns the number of elements in the queue.",
              "`empty()`: Returns `True` if the queue is empty, otherwise `False`.",
              "`full()`: Returns `True` if the queue is full, otherwise `False`."
            ]
          },
          {
            "type": "code",
            "language": "python",
            "code": "q = queue.Queue()\nq.put('A')\nprint(q.qsize())  # Output: 1\nprint(q.empty())  # Output: False\nprint(q.full())  # Output: False"
          }
        ]
      },
      {
        "title": "Queue Use Cases",
        "content": [
          {
            "type": "paragraph",
            "text": "Queues are used in various programming scenarios, such as:"
          },
          {
            "type": "bullets",
            "items": [
              "Task scheduling: Queues are used to manage tasks waiting to be executed.",
              "Breadth-First Search (BFS): A queue is used in BFS to explore nodes layer by layer.",
              "CPU scheduling: Processes are managed using a queue to determine execution order."
            ]
          }
        ]
      },
      {
        "title": "Dequeuing From an Empty Queue",
        "content": [
          {
            "type": "paragraph",
            "text": "In most queue implementations, dequeuing from an empty queue raises an error. In `queue.Queue`, the `get()` method blocks until an item becomes available, but you can prevent this by using a timeout."
          },
          {
            "type": "code",
            "language": "python",
            "code": "import queue\nq = queue.Queue()\ntry:\n    q.get(timeout=1)\nexcept queue.Empty:\n    print('Queue is empty')  # Output: 'Queue is empty'"
          },
          {
            "type": "paragraph",
            "text": "Using the `timeout` argument ensures the program doesnâ€™t block indefinitely while waiting for an item."
          }
        ]
      },
      {
        "title": "Conclusion",
        "content": [
          {
            "type": "paragraph",
            "text": "In this tutorial, we explored the basics of queues in Python and different ways to implement them using lists, `collections.deque`, and `queue.Queue`. We also looked at priority queues and common use cases for queues in programming. Queues are essential for handling tasks and operations where FIFO ordering is required."
          }
        ]
      }
    ]
  }  