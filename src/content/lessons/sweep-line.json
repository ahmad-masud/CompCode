{
    "title": "Sweep Line Algorithm",
    "premium": true,
    "lessons": [
      {
        "title": "Introduction to Sweep Line Algorithm",
        "content": [
          {
            "type": "paragraph",
            "text": "The sweep line algorithm is a powerful geometric technique used to solve problems involving intervals, points, or events that can be processed in a specific order. The idea is to 'sweep' a line across the plane and handle events as they occur, maintaining relevant information about the points or intervals intersecting the line."
          },
          {
            "type": "bullets",
            "items": [
              "The sweep line moves from left to right (or top to bottom) across the plane, processing events in a sorted order.",
              "Commonly used for solving computational geometry problems such as finding intersections of line segments, computing the convex hull, and finding the union of intervals.",
              "The key is maintaining an efficient data structure (like a balanced tree) to handle dynamic updates and queries as the line sweeps across the plane."
            ]
          }
        ]
      },
      {
        "title": "Key Concepts of Sweep Line",
        "content": [
          {
            "type": "bullets",
            "items": [
              "Events: Points or intervals where something important happens (e.g., start or end of an interval, intersection of two segments).",
              "Active Set: The set of elements (intervals or segments) that intersect the current position of the sweep line.",
              "Event Queue: A priority queue that keeps track of events to be processed, usually sorted by the x-coordinate or time."
            ]
          },
          {
            "type": "paragraph",
            "text": "As the sweep line progresses, events are processed, and the active set is updated by adding or removing elements. Queries about the active set are answered in real time."
          }
        ]
      },
      {
        "title": "Example: Line Segment Intersection",
        "content": [
          {
            "type": "paragraph",
            "text": "One of the classic applications of the sweep line algorithm is detecting intersections between line segments. The algorithm processes the start and end points of each line segment and maintains an active set of line segments that intersect the current sweep line."
          },
          {
            "type": "code",
            "language": "python",
            "code": "from sortedcontainers import SortedList\n\nclass Event:\n    def __init__(self, x, segment, is_start):\n        self.x = x\n        self.segment = segment\n        self.is_start = is_start\n\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Segment:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\n    def intersects(self, other):\n        # Check if two segments intersect (simplified version)\n        return max(self.start, other.start) <= min(self.end, other.end)\n\n# Sweep Line Algorithm for finding intersections\ndef find_intersections(segments):\n    events = []\n    for segment in segments:\n        events.append(Event(segment.start, segment, True))  # Start of the segment\n        events.append(Event(segment.end, segment, False))   # End of the segment\n    events.sort()  # Sort by x-coordinate\n\n    active_set = SortedList()\n    intersections = []\n\n    for event in events:\n        if event.is_start:\n            for active_segment in active_set:\n                if active_segment.intersects(event.segment):\n                    intersections.append((active_segment, event.segment))\n            active_set.add(event.segment)\n        else:\n            active_set.remove(event.segment)\n\n    return intersections\n\n# Example segments\nsegments = [Segment(1, 5), Segment(3, 7), Segment(2, 6)]\nprint(find_intersections(segments))  # Output: List of intersecting segments"
          },
          {
            "type": "paragraph",
            "text": "In this example, we process events (start and end points of segments) while maintaining an active set of segments. As each event is processed, we check for intersections between the new segment and the existing active segments."
          }
        ]
      },
      {
        "title": "Example: Finding the Union of Intervals",
        "content": [
          {
            "type": "paragraph",
            "text": "The sweep line algorithm can also be used to compute the union of intervals. By sweeping over the start and end points of intervals, we can track the total length covered by the intervals."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def union_of_intervals(intervals):\n    events = []\n    for start, end in intervals:\n        events.append((start, 'start'))\n        events.append((end, 'end'))\n    events.sort()\n\n    total_length = 0\n    active_intervals = 0\n    last_position = None\n\n    for x, event in events:\n        if active_intervals > 0 and last_position is not None:\n            total_length += x - last_position\n        if event == 'start':\n            active_intervals += 1\n        else:\n            active_intervals -= 1\n        last_position = x\n\n    return total_length\n\nintervals = [(1, 5), (2, 6), (8, 10)]\nprint(union_of_intervals(intervals))  # Output: 6"
          },
          {
            "type": "paragraph",
            "text": "In this example, we sweep over the start and end points of intervals and keep track of how many intervals are currently active. The total length covered by the union of intervals is calculated as the sum of lengths between consecutive active intervals."
          }
        ]
      },
      {
        "title": "Balancing Event Processing",
        "content": [
          {
            "type": "paragraph",
            "text": "Efficiently handling events and managing the active set is key to the sweep line algorithm. Data structures such as balanced binary search trees, heaps, or sorted lists are used to dynamically manage the active set and handle queries efficiently."
          },
          {
            "type": "bullets",
            "items": [
              "Balanced Trees: Provide O(log n) insertion and removal, making them useful for maintaining the active set.",
              "Priority Queues: Efficiently handle event processing by storing events sorted by their position in the sweep line.",
              "Sorted Lists: Useful for maintaining order when elements are added or removed from the active set."
            ]
          }
        ]
      },
      {
        "title": "Applications of the Sweep Line Algorithm",
        "content": [
          {
            "type": "bullets",
            "items": [
              "Line Segment Intersection: Detecting intersections between a set of line segments.",
              "Computing the Convex Hull: A problem in computational geometry where the smallest convex polygon is found that encloses a set of points.",
              "Finding the Union of Intervals: Summing the total length of overlapping intervals.",
              "Voronoi Diagrams: Partitioning a plane based on the distance to a set of points."
            ]
          }
        ]
      },
      {
        "title": "Advantages and Limitations of the Sweep Line Algorithm",
        "content": [
          {
            "type": "bullets",
            "items": [
              "Advantages: Efficient for solving geometric problems and can reduce time complexity in problems involving overlapping intervals or segments.",
              "Limitations: Can be difficult to implement for complex geometric problems, and handling edge cases (such as overlapping points) can be tricky."
            ]
          }
        ]
      },
      {
        "title": "Conclusion",
        "content": [
          {
            "type": "paragraph",
            "text": "The sweep line algorithm is a powerful tool for solving computational geometry problems. By processing events in a sorted order and maintaining an active set of intervals or segments, it can efficiently solve problems like intersection detection, interval union, and more. Although it requires careful implementation and efficient data structures, the algorithm significantly improves time complexity compared to brute-force approaches."
          }
        ]
      }
    ]
  }  