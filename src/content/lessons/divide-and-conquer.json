{
    "title": "Divide and Conquer",
    "lessons": [
      {
        "title": "Introduction to Divide and Conquer",
        "content": [
          {
            "type": "paragraph",
            "text": "Divide and Conquer is an algorithmic paradigm that works by recursively breaking a problem into two or more sub-problems of the same or related type, solving them independently, and then combining their solutions to solve the original problem."
          },
          {
            "type": "bullets",
            "items": [
              "Divide: Break the problem into smaller sub-problems.",
              "Conquer: Solve the sub-problems recursively.",
              "Combine: Merge the results of the sub-problems to form the final solution."
            ]
          }
        ]
      },
      {
        "title": "Classic Examples of Divide and Conquer",
        "content": [
          {
            "type": "bullets",
            "items": [
              "Merge Sort",
              "Quick Sort",
              "Binary Search",
              "Matrix Multiplication",
              "Closest Pair of Points"
            ]
          },
          {
            "type": "paragraph",
            "text": "Many of these algorithms are more efficient than their brute-force counterparts because they reduce the problem size by half with each step."
          }
        ]
      },
      {
        "title": "Merge Sort Algorithm",
        "content": [
          {
            "type": "paragraph",
            "text": "Merge Sort is a classic example of the divide and conquer strategy. It divides the array into halves, recursively sorts them, and then merges the sorted halves."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1"
          },
          {
            "type": "paragraph",
            "text": "Merge Sort has a time complexity of O(n log n), where n is the size of the input array. It works by recursively breaking the array in half and merging sorted halves."
          }
        ]
      },
      {
        "title": "Quick Sort Algorithm",
        "content": [
          {
            "type": "paragraph",
            "text": "Quick Sort is another divide and conquer algorithm. It selects a pivot element, partitions the array into two halves such that elements smaller than the pivot are on the left, and larger elements are on the right, then recursively sorts the subarrays."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        less_than_pivot = [x for x in arr[1:] if x <= pivot]\n        greater_than_pivot = [x for x in arr[1:] if x > pivot]\n        return quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot)"
          },
          {
            "type": "paragraph",
            "text": "Quick Sort has an average-case time complexity of O(n log n), but its worst-case time complexity is O(n^2), depending on the pivot choice. A good pivot selection strategy ensures better performance."
          }
        ]
      },
      {
        "title": "Binary Search",
        "content": [
          {
            "type": "paragraph",
            "text": "Binary Search is a simple divide and conquer algorithm that works on sorted arrays. It repeatedly divides the search interval in half and eliminates one half based on whether the target value is greater or smaller than the midpoint."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1"
          },
          {
            "type": "paragraph",
            "text": "Binary Search has a time complexity of O(log n), making it much faster than a linear search for large datasets."
          }
        ]
      },
      {
        "title": "Matrix Multiplication",
        "content": [
          {
            "type": "paragraph",
            "text": "Matrix multiplication using divide and conquer can be optimized using Strassen’s algorithm. It divides matrices into sub-matrices, recursively multiplies them, and combines the results."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def strassen_multiply(A, B):\n    # Assume A and B are square matrices of size 2^n\n    n = len(A)\n    if n == 1:\n        return [[A[0][0] * B[0][0]]]\n\n    mid = n // 2\n    A11 = [row[:mid] for row in A[:mid]]\n    A12 = [row[mid:] for row in A[:mid]]\n    A21 = [row[:mid] for row in A[mid:]]\n    A22 = [row[mid:] for row in A[mid:]]\n\n    B11 = [row[:mid] for row in B[:mid]]\n    B12 = [row[mid:] for row in B[:mid]]\n    B21 = [row[:mid] for row in B[mid:]]\n    B22 = [row[mid:] for row in B[mid:]]\n\n    # Strassen's sub-matrix products\n    M1 = strassen_multiply(add(A11, A22), add(B11, B22))\n    M2 = strassen_multiply(add(A21, A22), B11)\n    M3 = strassen_multiply(A11, subtract(B12, B22))\n    M4 = strassen_multiply(A22, subtract(B21, B11))\n    M5 = strassen_multiply(add(A11, A12), B22)\n    M6 = strassen_multiply(subtract(A21, A11), add(B11, B12))\n    M7 = strassen_multiply(subtract(A12, A22), add(B21, B22))\n\n    # Combine results\n    C11 = add(subtract(add(M1, M4), M5), M7)\n    C12 = add(M3, M5)\n    C21 = add(M2, M4)\n    C22 = add(subtract(add(M1, M3), M2), M6)\n\n    # Merge into one matrix\n    C = [C11[i] + C12[i] for i in range(mid)] + [C21[i] + C22[i] for i in range(mid)]\n    return C"
          },
          {
            "type": "paragraph",
            "text": "Strassen’s algorithm improves the time complexity of standard matrix multiplication from O(n^3) to O(n^2.81)."
          }
        ]
      },
      {
        "title": "Divide and Conquer Advantages",
        "content": [
          {
            "type": "bullets",
            "items": [
              "It helps solve complex problems by breaking them into manageable parts.",
              "Many problems that seem inefficient to solve through brute force can be optimized with divide and conquer.",
              "The recursive nature of divide and conquer often simplifies problem structure."
            ]
          }
        ]
      },
      {
        "title": "Divide and Conquer Disadvantages",
        "content": [
          {
            "type": "bullets",
            "items": [
              "Recursion adds overhead, especially for problems that don't reduce their size significantly.",
              "Combining sub-problems can sometimes be complex or inefficient, leading to higher time complexities."
            ]
          }
        ]
      },
      {
        "title": "Conclusion",
        "content": [
          {
            "type": "paragraph",
            "text": "Divide and Conquer is a fundamental algorithmic strategy that underpins many efficient algorithms. By dividing a problem into smaller pieces and recursively solving them, this approach significantly optimizes performance for certain classes of problems."
          }
        ]
      }
    ]
  }  