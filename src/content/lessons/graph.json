{
    "title": "Graphs",
    "lessons": [
      {
        "title": "Introduction to Graphs",
        "content": [
          {
            "type": "paragraph",
            "text": "A graph is a data structure consisting of a set of nodes (or vertices) and a set of edges that connect pairs of nodes. Graphs can be directed (edges have a direction) or undirected (edges have no direction). They can also be weighted, meaning each edge has an associated cost or weight."
          },
          {
            "type": "bullets",
            "items": [
              "Graphs consist of vertices (nodes) and edges (connections).",
              "Graphs can be directed or undirected.",
              "Graphs can be weighted (with edge weights) or unweighted."
            ]
          }
        ]
      },
      {
        "title": "Graph Representation in Python",
        "content": [
          {
            "type": "paragraph",
            "text": "In Python, graphs are commonly represented using an adjacency list or an adjacency matrix. The adjacency list is typically implemented as a dictionary where each key is a node, and its value is a list of adjacent nodes."
          },
          {
            "type": "code",
            "language": "python",
            "code": "graph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n"
          },
          {
            "type": "paragraph",
            "text": "In this example, the graph is represented as an adjacency list using a dictionary. Each key represents a node, and its value is a list of adjacent nodes."
          }
        ]
      },
      {
        "title": "Depth-First Search (DFS)",
        "content": [
          {
            "type": "paragraph",
            "text": "Depth-First Search (DFS) is a traversal algorithm that explores as far as possible along each branch before backtracking. It is typically implemented using recursion or a stack."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    print(start, end=' ')\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n\n# Example\ndfs(graph, 'A')  # Output: A B D E F C"
          },
          {
            "type": "paragraph",
            "text": "In this recursive DFS implementation, nodes are visited, and the algorithm recursively explores each neighbor before backtracking. DFS can be useful for exploring connected components and detecting cycles."
          }
        ]
      },
      {
        "title": "Breadth-First Search (BFS)",
        "content": [
          {
            "type": "paragraph",
            "text": "Breadth-First Search (BFS) is a traversal algorithm that explores all nodes at the present depth level before moving on to nodes at the next depth level. It is typically implemented using a queue."
          },
          {
            "type": "code",
            "language": "python",
            "code": "from collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        node = queue.popleft()\n        print(node, end=' ')\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n# Example\nbfs(graph, 'A')  # Output: A B C D E F"
          },
          {
            "type": "paragraph",
            "text": "In this BFS implementation, nodes are visited level by level. BFS is commonly used for finding the shortest path in an unweighted graph or for searching in layers."
          }
        ]
      },
      {
        "title": "Detecting Cycles in a Graph",
        "content": [
          {
            "type": "paragraph",
            "text": "Detecting cycles in a graph is important in many applications, such as dependency resolution. In an undirected graph, DFS can be used to detect cycles by checking back edges."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def detect_cycle_dfs(graph, node, visited, parent):\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if detect_cycle_dfs(graph, neighbor, visited, node):\n                return True\n        elif parent != neighbor:\n            return True\n    return False\n\n# Example usage\ndef has_cycle(graph):\n    visited = set()\n    for node in graph:\n        if node not in visited:\n            if detect_cycle_dfs(graph, node, visited, None):\n                return True\n    return False\n\nprint(has_cycle(graph))  # Output depends on the graph structure"
          },
          {
            "type": "paragraph",
            "text": "This DFS-based cycle detection checks whether there are any back edges in the graph, which indicate the presence of a cycle."
          }
        ]
      },
      {
        "title": "Graph Traversal with Edge Weights (Dijkstra’s Algorithm)",
        "content": [
          {
            "type": "paragraph",
            "text": "Dijkstra’s Algorithm is a greedy algorithm used to find the shortest path between nodes in a graph, particularly when the graph has non-negative edge weights."
          },
          {
            "type": "code",
            "language": "python",
            "code": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    return distances\n\n# Example graph with weights\ngraph_with_weights = {\n    'A': [('B', 1), ('C', 4)],\n    'B': [('A', 1), ('D', 2), ('E', 5)],\n    'C': [('A', 4), ('F', 3)],\n    'D': [('B', 2)],\n    'E': [('B', 5), ('F', 1)],\n    'F': [('C', 3), ('E', 1)]\n}\n\nprint(dijkstra(graph_with_weights, 'A'))  # Output: Shortest paths from A"
          },
          {
            "type": "paragraph",
            "text": "In this implementation, Dijkstra's algorithm finds the shortest paths from the start node to all other nodes in the graph. It uses a priority queue to always expand the node with the current shortest known path."
          }
        ]
      },
      {
        "title": "Topological Sorting in a Directed Acyclic Graph (DAG)",
        "content": [
          {
            "type": "paragraph",
            "text": "Topological sorting is used to order the nodes in a directed acyclic graph (DAG) in such a way that for every directed edge UV, vertex U comes before vertex V in the ordering. It is useful in scheduling tasks where some tasks must be completed before others."
          },
          {
            "type": "code",
            "language": "python",
            "code": "def topological_sort(graph):\n    visited = set()\n    stack = []\n\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n        stack.append(node)\n\n    for node in graph:\n        if node not in visited:\n            dfs(node)\n    return stack[::-1]\n\n# Example\ndag = {\n    'A': ['C'],\n    'B': ['C', 'D'],\n    'C': ['E'],\n    'D': ['F'],\n    'E': ['F'],\n    'F': []\n}\n\nprint(topological_sort(dag))  # Output: Topological order"
          },
          {
            "type": "paragraph",
            "text": "This DFS-based algorithm performs a topological sort by visiting nodes recursively and pushing them onto a stack once all their dependencies have been visited."
          }
        ]
      },
      {
        "title": "Graph Use Cases",
        "content": [
          {
            "type": "paragraph",
            "text": "Graphs have many practical applications, including:"
          },
          {
            "type": "bullets",
            "items": [
              "Modeling networks (e.g., social networks, transportation networks).",
              "Solving shortest path problems (e.g., road navigation, networking).",
              "Dependency management (e.g., task scheduling, course prerequisites).",
              "Web crawling and searching (e.g., search engines)."
            ]
          }
        ]
      },
      {
        "title": "Conclusion",
        "content": [
          {
            "type": "paragraph",
            "text": "In this tutorial, we covered the basics of graphs, common traversal algorithms like DFS and BFS, cycle detection, Dijkstra's algorithm for shortest paths, and topological sorting. Graphs are an essential tool for modeling relationships and solving problems in various fields, including computer science, networking, and operations research."
          }
        ]
      }
    ]
  }  